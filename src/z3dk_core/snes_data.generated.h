#pragma once
#include <cstdint>
#include <array>
#include <cstddef>

namespace z3dk {

struct SnesRegisterInfo {
    uint32_t address;
    const char* name;
    const char* description;
};

constexpr std::array<SnesRegisterInfo, 30> kSnesRegisters = {
    SnesRegisterInfo{ 0x2100, "INIDISP", "INITIAL SETTINGS FOR SCREEN\nD7 D6 D5 D4 D3\nBLANK\nING F3\n'-\nD2 D1 DO\nFADE IN/OUT (0-15)\n2100H\nI F2 I F1 I Fa\n.J\n~ SCREEN BRIGHTNESS: Determine\nthe screen brightness (16-stages)\nF31 F2 I F1 I FO 1 BRIGHTNESS\n1 1 BRIGHT\n1 1 0\no 0 0 0 DARK\n-~ BLANKING: FORCED BLANKINGI 01:. NON-BLANKING L- BLANKING" },
    SnesRegisterInfo{ 0x2102, "OAMADDL", "ADDRESS FOR ACCESSING OAM (OBJECT ATTRIBUTE MEMORY)\nADDRESS\n07 DO\nOAM ADDRESS 2102H\nA7 A6 I A5 I A4 I A3 I A2 I A 1 AO\nOAM PRIORITY ROTATION OAM ADDRESS MSB" },
    SnesRegisterInfo{ 0x2105, "BGMODE", "BG MODE & CHARACTER SIZE SETTINGS\n07 06 D5 D4 D3 D2 01 DO\nBG SIZE BG3 BG MODE\n2105H\nBG 4 I BG 3 I BG2 I BG 1 PRIO. M2 I M1 I MO\n.........\nREEN MODE SELECT:\nSee BG L L;BGS~ Screen Mode Summary\n-5) (page A\nHIGHEST PRIORITY 0 ESIGNATION FOR BG-3\nty during BG Mode 0 or 1 Make BG3 highest priori\n(page A-19)\nC O:OFF\n1: ON\n~ BG SIZE DESIGNATION: Desi nate the size for g each BG Character\n(pages A-21 and A-22)\nI 0: 8 X 8 DOT/CHARACTER\nL 1: 16 X 16 DOT/CHARACTER\n16 DOT\n~\n16 DOT 1\n00 01 In case CHR NAME of SC data is \"OOH\":\n10 11 ... CHARACTER NAME (HEX) .." },
    SnesRegisterInfo{ 0x2106, "MOSAIC", "SIZE & SCREEN DESIGNATION FOR MOSAIC DISPLAY\n07 06 D5 D4 D3 02 01 DO\nMOSAIC SIZE MOSAIC ENABLE\n2106H\nM3 MO BG4 BG1\nMOSAIC MODE SELECT:\nON/OFF for Mosaic Mode of each BG\n10:OFF\nL- 1: ON\nMOSAIC MODE SIZE DESIGNATION: DESIGNATE MOSAIC MODE SIZE\n(page A-7)\n256 MODE 512 MODE (H X V)\nM31M21M11MO SIZE M31M21M11MO SIZE ( ): NON-INTERLACE\n0 0 0 0 2 X 2 DOT t X 1 DO~ 0 0 0 1 4 X 4 DOT 4 X 2 DO\n0 0 1 0 6 X 6 DOT 6 X 3 DOT\n0 0 0 0 1 X 1 DOT\n0 0 0 1 2 X 2 DOT\n0 0 1 0 3 X 3 DOT\n            1 1 1 0 30 X 30 DOT ~30 X 15 DOT\n1 1 1 1 32 X 32 DOT 32 X 16 DOT\n1 1 1 0 15 X 15 001\n1 1 1 1 16 X 16 DOl\n(NeL PC 48)\n2-27-3\n---## Page 118\nSNES DEVELOPMENT MANUAL" },
    SnesRegisterInfo{ 0x2107, "BG1SC", "ADDRESS FOR STORING SC-DATA OF EACH BG & SC SIZE DESIGNATION\n(MODE 0.., 6)\nD7 D6\nBG1\nAS I A4 I\nBG2\nAS I A4 I\nBG3\nAS I A4 I\nBG4\nAS I A4 I\nDS D4 D3 D2 D1 DO\nSC BASE ADDRESS BG1 SC SIZE\n2107 H\nA3 I A2 I A1 I AO S1 I SO\nSC BASE ADDRESS BG2 SC SIZE\n2108 H\nA3 I A2 I A1 I AO S1 I SO\nSC BASE ADDRESS BG3 SC SIZE\n2109H\nA3 I A2 I A1 I AO S1 I SO\nSC BASE ADDRESS BG4 SC SIZE\n210AH\nA3 I A2 I A1 I AO S1 I SO\nI:SC~EEN SIZE DESIGNATION\n(pages A-21 and A-22)\nDesignate Background Screen\nSize\nBACKGROUND SCREEN BASE ADDRESS (UPPER 6-BIT)\nDesignate the segment in which BG-SC data in the VRAM is\nstored. (1 K-WORD/SEGMENT)\nr--_~ ______ S;::;..C=..;R:..;.;E=.::E=N...:....::;.S=IZ==,E & SCREEN REPETITION\nS1 SO\no 0\no\nSCREEN SIZE S1 SO SCREEN SIZE\n---------,\nSCO SCO' , , , ...... ~~~ ........ ~--, , , , ,\n, SCO ' SCO' , ______ L _____ ,\nSCO SC1\n--, ,\n'SCO - SC1' 1 ______ L _____ ,\no\n(NeL PC 49)\n2-27-4\n---------, SCo SCO, , , ,\nI--------for~~~ ......... ~ - - ,\n, ,\nSC1 SC1 : a....-_---' _____ _\nSCO SC1 ---SCO-:\n~~~ -\n--\nI--------for~~~--~-----i\n, , ,\nSC2 SC3 SC2, -----,\n- , , ,\n- , , SCO SC 1 - SCO ,\n~~~~~~.~~~~~~~~~~~-\n---## Page 119\nPPU REGISTERS" },
    SnesRegisterInfo{ 0x210b, "BG12NBA", "BG CHARACTER DATA AREA DESIGNATION\nD7 D6 D5 04 D3 D2 D1 DO\nBG2 NAME BASE ADDRESS BG1 NAME BASE ADDRESS\n210B H\nA3 I A2 I A1 I AO A3 I A21 A1 I AO\nBG4 NAME BASE ADDRESS BG3 NAME BASE ADDRESS\n210C H\nA3 1A2 I A1 I AO A3 1A2 I A1 I AO\nBACKGROUND NAME BASE ADDRESS (UPPER 4-BIT):\nDesignate the segment address in the VRAM in which BG character data\nis stored. (4K-WORD/SEGMENT)" },
    SnesRegisterInfo{ 0x210f, "BG2HOFS", "HN SCROLL VALUE DESIGNATION FOR BG-2, 3, 4\nD7 D6\nHO 7\nV07\nD5 D4 D3 D2 D1 DO\nBG H-OFFSET (LOW, HIGH) 210FH\n(HO 9) (HO 8) 2111H\nHOO 2113H\nBG V-OFFSET (LOW, HIGH) 2110H\n2112H\n2114H\n1 O-Bit maximum (0 .... 1023) of the HN scroll value can be designated\n(page A-10)\nBy writing to the register twice, the data can be set in the order of Low\nand High." },
    SnesRegisterInfo{ 0x2115, "VMAINC", "VRAM ADDRESS INCREMENT VALUE DESIGNATION\nD7\nH/L\nINC\nD6 D5 D4 D3 D2 D1 DO\nG1\n0\n1\n1\n0\n0\n0\n0\n-RAM ADDRESS SEQUENCE MODE\nFULL GRAPHIC SC INCREMENT 2115H\nG1 GO 11 10\nb' J '\nDeSignate the increment value for the VRAM\naddress. (page A-8)\nGO 11 10 INCREMENT VALUE\n1 0 0 Increment by 8 (for 32 times) (2-Bit Formation)\n0 0 0 Increment by 8 (for 64 times) (4-Bit Formation)\n1 0 0 Increment by 8 (for 128 times) (8-Bit Formation)\n0 0 0 Address Increments 1 BY 1\n0 0 1 Address Increments 32 BY 32\n0 1 0 Address Increments 128 BY 128\n0 1 1 Address Increments 128 BY 128\nDesignate the increment timing for the address\n[\n0: The address will be increased after the data has been written to register <2118H>\nor the data has been read from register <2139>.\n1: The address will be increased after the data has been written to register <2119H>\nor the data has been read from register <213AH>.\n(NeL PC 51)\n2-27-6\n---## Page 121\nPPU REGISTERS" },
    SnesRegisterInfo{ 0x2116, "VMADDL", "ADDRESS FOR VRAM READ AND WRITE\nD7 D6 DS D4 D3 D2 D1 DO\nVRAM ADDRESS (LOW)\nI 2116H\nA7 A6 AS A4 A3 A2 A1 AO\nVRAM ADDRESS (HIGH)\n2117H\nA1S I A14 I A13 I A12 I A11 I A10 I A9 I AB" },
    SnesRegisterInfo{ 0x2122, "CGDATA", "DATA FOR CG-RAM WRITE\nD7 D6 D5 D4 D3 D2 D1 DO\nCG RAM DATA (LOW, HIGH)\nI\n(D 14) I (D 13) I (D 12) I (D 11) I (D 1 0) I (D9) I (D8)\nD7 D6 D5 D4 D3 D2 D1 DO\n2122H\n This is the color generator data to be written at any address of the\nCG-RAM.\n The mapping of BG1 ,... BG 4 and OBJ data in the CG-RAM will be\ndetermined, which is performed by every mode selected by \"BG\nMODE\" of register <21 OSH>. (See page A-17)\n There are the color data of a palettes for each screen of BG1 -\nBG4. The palette selection is determined by 3-bit of the SC data\n\"COLOR.\"(Refer to page A-1 0)\n Because the CG-RAM data is 1S-bit/word, it is necessary to set low\ner a-bit first to this register and then upper 7-bit should be set. When\nboth lower and upper are set, the address will be increased by 1 au\ntomatically.\nNOTE: After the address is set, the data should be written in the or\nder of low, then high. This is similar to the OAM Data register.\nNOTE: The data can be written only during H/V BLANK or FORCED\nBLANK period.\n(NeL PC 55)\n2-27-11\n---## Page 126\nSNESDEVELOPMENTMANUAL" },
    SnesRegisterInfo{ 0x2123, "WHO", "WINDOW POSITION DESIGNATION (Refer to page A-18)\n_.:.0.;..7 _--=D;.::;6_---:D::;.;:5~_.:;.D..:.4 _ __=D;.:3~_:::;.;D2=__ _ _=D;..;.1 _ __=D;.:0~ 2126H WINDOW-1 LEFT\nP7\nWINDOW HO/H1/H2/H3 POSITION 2127H POSITION\nPO\nDESIGNATION\n2128H\n2129H\nWINDOW HO POSITION <2126H>:WINDOW-1 Left Position Designation. It can be set in range 0 -255\nWINDOW H1 POSITION <2127H>:WINDOW-1 Right Position Designation. It can be set in range 0 -255\nWINDOW H2 POSITION <2128H>:WINDOW-2 Left Position Designation. It can be set in range 0 -:--255\nWINDOW H3 POSITION <2129H>:WINDOW-2 Right Position Designation. It can be set in range 0 -255\nNOTE: If 'LEFT POSITION SETTING VALUE> RIGHT POSITION VALUE\" is assumed, there will\nbe no range of the window.\n(NeL PC 56)\n2-27-12\n---## Page 127\nPPU REGISTERS" },
    SnesRegisterInfo{ 0x212a, "WBGLOG", "MASK LOGIC SETTINGS FOR WINDOW-1 & 2 ON EACH SCREEN\nD7 D6 DS D4 D3 D2 D1 DO\nWINDOW LOGI\nBG4 BG3 BG2 BG1 212AH\nD1 DO\nf\niNbO~ LOGiC I\n....\n____________________ ~ ____ C_o.lo_r ____ '__ ___ O~B_J __ ~ 212BH D1 DO D1 I DO .\nWINDOW LOGIC: SET MASK LOGIC FOR WINDOW-1 & 2\nWhen both Window-1 and Window-2 are \"IN,\" the shaded portion will be masked as follows:\nW1 : Window 1\nW2: Window 2\nD1 DO\n'-------------1 0 0\no 1\n1 0\n1 1\nLOGIC\nOR\nAND\nXOR\nXNOR\nW1\nNOTE: \"IN/OUT\" of registers <2123H> <2124H> <212SH> becomes the \"NOT logic\" for each\nWindow-1 and Window-2.\n(NCL PC 57)\n2-27-13\n---## Page 128\nSNES DEVELOPMENT MANUAL" },
    SnesRegisterInfo{ 0x212c, "TM", "MAIN SCREEN DESIGNATION\nD7 D6 D5 04\nOBJ" },
    SnesRegisterInfo{ 0x212d, "TS", "SUB SCREEN DESIGNATION\nD7 06 D5 D4 03 02 01 DO\nI\nTHROUGH SUB I 212DH\nOBJ I BG4 J BG3J BG2 I BG1 .\n~____________ J\nL SUB SCREEN DESIGNATION:\nDesignate the screen (BG1 ..... BG4, OBJ)\nto be displayed as SUB-Screen.\nDesignate the screen to be added for the\nscreen addition/subtraction\n[\n0: DISABLE\n1 : ENABLE\nNOTE: When the screen addition/subtraction is functioning, the SUB screen is a screen\nto be added or subtracted against the MAIN screen.\n(NeL PC 58)\n2-27-14\n---## Page 129\nPPU REGISTERS" },
    SnesRegisterInfo{ 0x212e, "TMW", "WINDOW MASK DESIGNATION FOR MAIN SCREEN\n07 06 D5" },
    SnesRegisterInfo{ 0x212f, "TSW", "WINDOW MASK DESIGNATION FOR SUB SCREEN\n07 D6 D5 D4 03 02 01 DO\nTHROUGH SUB (WINDOW)\n212FH\nOBJ I BG4 I BG3 I BG2 I BG1\n..... _----- ---------\"\nL WINDOW MASK DESIGNATION FOR\nSUB SCREEN:\nIn the window area designated by\nregister <2123H> ..... <2129H>, the\nscreen to be displayed can be\ndesignated, which is selected among\nthe Sub screen designated by\nregister <212DH>.\n[\n0: DISABLE\n1 : ENABLE\nNOTE: When the screen addition/subtraction is functioning, the SUB screen is a screen\nto be added or subtracted against the MAIN screen.\n(NeL PC 59)\n2-27-15\n---## Page 130\nSNES DEVELOPMENT MANUAL" },
    SnesRegisterInfo{ 0x2130, "CGSWSEL", "INITIAL SETTINGS FOR FIXED COLOR ADDITION OR SCREEN ADDITION\nD7 D6 D5 D4 D3 D2 D1 DO\nCOLOR WINDOW ON/OFF CC ADD DIRECl\nMAIN SW (A) SUB SW (B) 2130H\nM1 I MO I S1 I SO ENABLE SELEC\"\nr----~~T\n~ FIXED COLOR\nDIRECT SELECT (Refer to p. A-17):\nThe VRAM data (Color & Character\ndata) become the color data directly.\n(Only when mode-3, 4 & 7 are\nselected.)\n[ 0\n1\n: DISABLE\n: ENABLE\nADDITION/SUBTRACTION ENABLE:\nDesignate whether 2 kinds of the data should\nbe aaded/subtracted from each other or not,\nwhich are the fixed color set by register\n<2132H> and the color data whicti is set to\nthe CGRAM.\n[\n0 : ADDITION/SUBTRACTION\nFOR FIXED COLOR\n1 : ADDITION/SUBTRACTION\nFOR SUB SCREEN\n-----.. COLOR WINDOW ON/OFF MAIN/SUB SWITCH:\nWhen the Color Window is functioning,\nthe assignment of the window area for\nMAIN and SUB screens can be designated.\n~~) I/~g FUNCTION\n0 0 ON jAil the time) 0 1 ON Inside window only\n1 0 ON Outside window only)\n1 1 OF (All the time)\n(NeL PC 60)\n2-27-16\n---## Page 131\nPPU REGISTERS" },
    SnesRegisterInfo{ 0x2131, "CGADSUB", "ADDITION/SUBTRACTION & SUBTRACTION DESIGNATION FOR EACH BG SCREEN\nOBJ & BACKGROUND COLOR\nD7 D6 D5 D4 D3 D2 D1 DO\nADD 1/2 ADD or SUB ENABLE\n2131H\nSUB ENABLE BACK 1 OBJ 1 BG 41 BG 31 BG 21 BG 1\n~ , COLOR oX AOOITION/SUBT~ACTION ENABLE:\nDesignate the color data of BG1 .... BG4, OBJ, or Back in\nthe main screen for addition/subtraction of the Sub screen\ncolor data (or fixed color data.)\n[ O:DISABLE\n1 : ENABLE (Addition/Subtraction function: ON)\nNote: When OBJ is designated, the Addition/Subtraction\nfunction is available only when the OBJ color palette is 4\nthrough 7.\n~ \"1/2 OF COLOR DATA\" DESIGNATION:\nWhen color constant addition/subtraction or screen addition/\nsubtraction is performed, designate whether the RBG result in the\naddition/subtraction area should be \"1/2\" or not. The back\n(color constant) area on the Subscreen, will not become \"1/2\"\n-0 : DISABLE\nL 1 : ENABLE (1/2 function: ON)\nL.....-----1~~ COLOR DATA ADDITION/SUBTRACTION SELECT:\nIn the case of executing screen\naddition/subtraction designate\neither addition or subtraction mode.\n[ 0: ADDITION MODE SELECT\n1 : SUBTRACTION MODE SELECT\n(NeL PC 60)\n2-27-17\n---## Page 132\nSNES DEVELOPMENT MANUAL" },
    SnesRegisterInfo{ 0x2132, "COLDATA", "FIXED COLOR DATA FOR FIXED COLOR ADDITION/SUBTRACTION\nD7 D6 D5 D4 D3 D2 D1 DO\nCOLOR CONSTANT DATA\nCOLOR BRILLIANCE DATA 2132H\nBLUE IGREENI RED I D4 I D3 I D2 I D1 I DO\n______ -----..... J\nT\nCOLOR CONSTANT DATA:\nSet the color constant data for color constant\naddition/subtraction.\nCOLOR DESIGNATION: Sit for Selecting Desired Color\nR/G/S brightness should be set using 5-bit data. Example:\nRED . COH, 3FH f=OOH, G=OOH, R=1 FH)\nGREEN: AOH,5FH S=OOH,G=1FH,R=OOH}\nSLUE . 60H,9FH ( =1 FH, G=OOH, R=OOH)\nWHITE. FFH\nSLACK: EOH\n(NeL PC 61)\n2-27-18\n---## Page 133\nPPU REGISTERS\n.. . .................................................... -:-:-:-:.:-... :-:-:::-:::::::-:-:-:::::::::::::::.::::::::::::::::::::-:-:::-:::::-:::::-:::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::-:::::::::-:::::::::::::::::::::::::::::::::::::::::::{:::::::::>>:<::::///:>\\J" },
    SnesRegisterInfo{ 0x2133, "SETINI", "SCREEN INITIAL SETTING\nD7 D6 D5 D4 03 D2 D1 DO\nEXT. EXT. PSEUDO 2~ 08J-V INTER- 2133H\nSYNC. INPUT 512 239 SELECT LACE\nr SCANNING INTERLACE(1)\nNON/INTERLACE(O) SELECTION:\n(Related to <21 05H\n~OBJ V-DIRECTION DISPLAY:*\nIn the interlace mode, select either 1 dot\nper line or 1 dot repeated every 2 lines. If \"1\"\nIS written, the OBJ appears to be reduced to\nhalf its vertical size .\n.. BG V-DIRECTION DISPLAY:\nSwitch the display line of a field to 224-Line or 239-Line.\n(In case of interlace mode, it will be doubled dot.)\n[ 0\n1\n: 224 LINES\n: 239 LINES\n~ HORIZONTAL PSEUDO 512 MODE:\nAn imaginary resolution of 512 (Horizontal) can\nbe created by shifting the SUB screen half dot to\nthe left, alternately every field: r 0\n1\n. DISABLE\nL : ENABLE\n~ EXTBG MODE (SCREEN EXPAND):\nEnable the data supplied from the external LSI. For the Super NES,\nenable when the screen with priority is used on mode-7 .\n.. EXTERNAL SYNCHRONIZATION:\nUsed for super-imposing images, etc. Normally, \"0\" should be written.\n* If \"01\" is set in non-interlace mode, even and odd numbered lines of the OBJ\nwill be displayed alternately every field.\n(NeL PC 61)\n2-27-19\n---## Page 134\nSNES DEVELOPMENT MANUAL\n...................................................................... : .. : ..... : ... : .. : ... ::::.}}}}  }  }:>}}>(::::. ..........   I" },
    SnesRegisterInfo{ 0x2134, "MPVL", "MULTIPLICATION RESULT\nD7 D6 D5 D4 D3 D2 D1 DO\n_ ______ ~~ __ ~ ____ M __ P_V_(_L_O_W~) __________ ~_M_O __ I 2134H M7 M6 M5 M4 I M3 I M2 M1 .\n.... __ ~~~~ __ ~~~M~P.V_(~M~ID~)~~~'--~~ __ M_8~1 2135H M 15 M 14 I M 13 I M 12 I M 11 I M 10 I M9 .\nM23\nM P V (HIGH) 2136H\nM16\nThis is a Multiplication result (complement of 2) and can be read by setting 16-bit to\nregister <211BH> and setting 8-Bit data to register <211 CH>" },
    SnesRegisterInfo{ 0x2137, "SLHV", "SOFTWARE LATCH FOR HN COUNTER\nD7\nSL7\nD6 D5 D4 D3 D2 D1 DO\nSOFT LATCH FOR H/V COUNTER 2137H\nSLO\nThis is a register, which generates the pulse for latching the H/V counter value.\nThe HN counter value at the pOint when register <2137H> is read can be latched.\nThe data which was read is meaningless data.\nThe H/V counter value latched can be referred by registers <213CH> and\n<213DH>.\n(NeL PC 62)\n2-27-20\n---## Page 135\nPPU REGISTERS\nI>:,::::,:,,:,:::::::::::: .................. '.' ........... ::.::::::::::::::::::::::::::::::::,',::::><,>:':':,::::1" },
    SnesRegisterInfo{ 0x2138, "OAMDATA", "READ DATA FROM OAM\nD7 D6\nD7\nDS D4 D3 D2 D1 DO\nOAM DATA (LOW, HIGH)\n2138H\nDO\nThis is a register, which can read the data at any address of the OAM.\nWhen the address is set to register <2102H> <2103H> and register <2138H> is\nalso accessed, the data can be read in the order of Low 8-Bit/High 8-Bit. Afterward,\nthe address will be increased automatically, and the data of the next address can\nbe read.\nNOTE: The data can be read only during HN BLANK or FORCED BLANK period." },
    SnesRegisterInfo{ 0x2139, "VMDATAL", "READ DATA FROM VRAM\nD7\nD7\nD1S I\nD6 DS D4 D3 D2 D1 DO\nVRAM DATA (LOW)\nI 2139H\nD6 DS D4 D3 D2 D1 DO\nVRAM DATA (HIGH)\n213AH\nD14 I D13 I D12 I D11 I D10 I D9 I D8\nThis is a register, which can read the data at any address of the VRAM.\nThe initial address should be set by registers <2116> and <2117H>. The data can\nbe read by the address which has been set initially.\nWhen reading the data continuously, the first data for the address increment\nshould be read as \"dummy\" data after the address has been set.\nQuantity to be increased will be determined by \"SC INCREMENT\" of register\n<211SH> and the setting value of the \"FULL GRAPHIC.\"\nNOTE: The data can be read only during HN BLANK or FORCED BLANK period.\n(NeL PC 63)\n2-27-21\n---## Page 136\nSNES DEVELOPMENT MANUAL" },
    SnesRegisterInfo{ 0x213b, "CGDATA", "READ DATA FROM CG-RAM\n07 06 05 04 03 02 01 00\nCG DATA (LOW, HIGH)\n213BH (014) (013) I (012) (011) (010) (09) I (08)\n07 I 06 I 05 04 I 03 I 02 I 01 00\nThis is a register, which can read the data at any address of the CG-RAM.\nThe initial address can be set by register <2121 H>. The lower 8-Bit is read first,\nand then the upper 7 -Bit will be read by accessing the register. The current ad\ndress will be increased to the next address at the same time the upper 7 -Bit is\nread.\nNote: The data can be read only during H/V blank or forced blank period." },
    SnesRegisterInfo{ 0x213c, "OPHCT", "H/V COUNTER OATA BY EXTERNAL OR SOFTWARE LATCH\n07 06\nH7\nV7\n05 04 03 02 01 00\nOUTPUT DATA OF H-COUNTER\n(H8) 213CH\nHO\nOUTPUT OATA OF V-COUNTER\n(V8) 213DH\nVO\nThe HN counter is latched by reading register <2137H>, and its H/V counter val\nue can be read by this register.\nThe H/V counter is also latched by the external latch, and its value can be read by\nthis register.\nIf register <213CH> or <2130H> is read after register <213FH> has been read,\nthe lower 8-Bit data will be read first, and then the upper 1-Bit will be read by\nreading the register.\n(NeL PC 64)\n2-27-22\n---## Page 137\nPPU REGISTERS" },
    SnesRegisterInfo{ 0x213e, "STAT77", "PPU STATUS FLAG & VERSION NUMBER\n07 D6 D5 04 D3 D2 D1 DO\nTIME RANGE MASTER 5C77 VERSION NUMBER\n213EH\nOVER OVER /SLAVE I I I\n'-( MASTER I SLAVE MODE SELECT: LSI MODE (Normally \"0\" is set)\n~ OBJ DISPLAY STATUS ON A HORIZONTAL LINE\n[\nRANGE: When Quantity of the OBJ (regardless of the size) becomes 33 pcs or more,\n\"1\" will be set.\nTIME: When quantity of the OBJ which is converted to \"8 x 8-SIZE\" is 35 pcs or more,\n\"1\" will be set\nNOTE: The flag will be reset at the end of the V-BLANK period." },
    SnesRegisterInfo{ 0x213f, "STAT78", "PPU STATUS FLAG & VERSION NUMBER\n07 D6\nFIELD EXT.\nLATCH\n05 04\nNTSC\n/PAL\nD3 D2 D1 DO\n5C78 VERSION NUMBER\nl DISPLAY METHOD [0: NTSC\n1 : PAL\n213FH\nEXTERNAL LATCH FLAG: When the external signal (Light Pen, etc.) is applied, it\nenables to latch the HN counter value. It is connected to I/O port d7 In SNES.\n(Refer to page 1-28-1.)\nThis is a status flag, which indicates whether the 1 st or 2nd field is scanned at the interlace\nmode. (The definition is different from the field of NTSC.)\n[ 0 : 1ST FIELD\n1 : 2ND FIELD\nNOTE: When this register is read, registers <213CH> <213DH> will be initialized individually in the\norder of Low and High.\n(NeL PC 65)\n2-27-23\n---## Page 138\nSNES DEVELOPMENT MANUAL" },
    SnesRegisterInfo{ 0x2140, "APUIOO", "COMMUNICATION PORT WITH APU\nD7 D6 D5 D4\nAPU 1/0\nD3 D2 D1\nPORT\nDO 2140H\n2141H\n2142H\n2143H\n The port provides more registers for the purpose of IN/OUT, which\nare 8 registers in total in the APU. Therefore, the different register\nwill be accessed, whether reading or writing for the same address.\n Refer to Part 2 of this manual for the details of the communication\nmethod.\n(NCLPG 66)\n2-27-24\n---## Page 139" },
    SnesRegisterInfo{ 0x2180, "WMDATA", "DATA to consecutively read from and write to WRAM\nD7 D6 D5 D4 D3 02 D1 DO\nWORK RAM DATA\nI\n2180H\n~A~7~~A~6~~~A5~LI~A4~~I~A~3~I~A=2~~A~1~~A~0~.\n Data to consecutively read and write at any address of WRAM\nPPU REGISTERS\n Data is read and written at address set by register <2181 H> .... <2183H>, and\naddress automatically increases each time data is read or written." },
};

struct OpcodeDocInfo {
    const char* mnemonic;
    const char* full_name;
    const char* description;
    const char* flags;
    const char* timing_table;
};

constexpr std::array<OpcodeDocInfo, 91> kOpcodeDocs = {
    OpcodeDocInfo{ "ADC", "Add With Carry", "Add the data located at the effective address specified by the operand to the con\ntents of the accumulator; add one to the result if the carry flag is set, and store the\nfinal result in the accumulator.\nThe 65x processors have no add instruction which does not involve the carry. To\navoid adding the carry flag to the result, you must either be sure that it is already\nclear, or you must explicitly clear it (using CLC) prior to executing the ADC\ninstruction.\nIn a multi-precision (multi-word) addition, the carry should be cleared before the\nlow-order words are added; the addition of the low word will generate a new carry\nflag value based on that addition. This new value in the carry flag is added into the\nnext (middle-order or high-order) addition; each intermediate result will correctly\nreflect the carry from the previous addition.\nd flag clear; Binary addition is performed.\nd flag set; Binary coded decimal (BCD) addition is performed.\n8-bit accumulator (all processors): Data added from memory is eight-bit.\n16-bit accumulator (65802/65816 only, m = 0): Data added from memory is six\nteen-bit: the low-order eight bits are located at the effective address; the high-order\neight bits are located at the effective address plus one.", "Flags Affected: n v", nullptr },
    OpcodeDocInfo{ "AND", "And Accumulator with Memory", "Bitwise logical AND the data located at the effective address specified by the\noperand with the contents of the accumulator. Each bit in the accumulator is\nANDed with the corresponding bit in memory, with the result being stored in the\nrespective accumulator bit.\nThe truth table for the logical AND operation is:\nSecond Operand\n0 1\nFirst Operand\n0 0 0\n1 0 1\nFigure 18.1. AND Truth Table.\nThat is, a 1 or logical true results in a given bit being true only if both elements\nof the respective bits being ANDed are Is, or logically true.\n8-bit accumulator (all processors): Data ANDed from memory is eight-bit.\n16-bit accumulator (65802/65816 only, m = 0): Data ANDed from memory is\nsixteen-bit: the low-order byte is located at the effective address; the high-order\nbyte is located at the effective address plus one.", "Flags Affected: n", nullptr },
    OpcodeDocInfo{ "ASL", "The syntax for accumulator addressing, using the  (arithmetic", nullptr, nullptr, nullptr },
    OpcodeDocInfo{ "BCC", "Branch if Carry Clear", "The carry flag in the P status register is tested. If it is clear, a branch is taken; if it\nis set, the instruction immediately following the two-byte BCC instruction is exe\ncuted.\nIf the branch is taken, a one-byte signed displacement, fetched from the second\nbyte of the instruction, is sign-extended to sixteen bits and added to the program\ncounter. Once the branch address has been calculated, the result is loaded into the\nprogram counter, transferring control to that location.\nThe allowable range of the displacement is   128 to +127 (from the instruction\nimmediately following the branch).\nBCC may be used in several ways: to test the result of a shift into the carry; to\ndetermine if the result of a comparison is either less than (in which case a branch\nwill be taken), or greater than or equal (which causes control to fall through the\nbranch instruction); or to determine if further operations are needed in multi-preci\nsion arithmetic.\nBecause the BCC instruction causes a branch to be taken after a comparison or\nsubtraction if the accumulator is less than the memory operand (since the carry flag\nwill always be cleared as a result), many assemblers allow an alternate mnemonic\nfor the BCC instruction: BLT, or Branch if Less Than.", "Flags Affected: -------------------", "Codes:\nAddressing Mode+ + Syntax\nOpcode\n(hex)\nAvailable on:\n6502 65C02 65802/816\n#o/\nBytes\n*of\nCycles\nProgram Counter Relative BCC nearlabel\n(or BLT nearlabel)\n90 X X  X 2 2 u\n1 Add 1 cycle if branch is taken\n2 Add 1 more cycle if branch taken crosses page boundary on 6502, 65C02, or 65816/65802's 6502 emulation mode\n(e = 1 )" },
    OpcodeDocInfo{ "BCS", "Branch if Carry Set", "The carry flag in the P status register is tested. If it is set, a branch is taken; if it is\nclear, the instruction immediately following the two-byte BCS instruction is exe\ncuted.\nIf the branch is taken, a one-byte signed displacement, fetched from the second\nbyte of the instruction, is sign-extended to sixteen bits and added to the program\ncounter. Once the branch address has been calculated, the result is loaded into the\nprogram counter, transferring control to that location.\nThe allowable range of the displacement is 128 to + 127 (from the instruction\nimmediately following the branch).\nBCS is used in several ways: to test the result of a shift into the carry; to deter\nmine if the result of a comparison is either greater than or equal (which causes the\nbranch to be taken) or less than; or to determine if further operations are needed in\nmulti-precision arithmetic operations.\nBecause the BCS instruction causes a branch to be taken after a comparison or\nsubtraction if the accumulator is greater than or equal to the memory operand\n(since the carry flag will always be set as a result), many assemblers allow an alter\nnate mnemonic for the BCS instruction: BGE or Branch if Greater or Equal.", "Flags Affected: -------------------", "Codes:\nAddressing Mode Syntax\nOpcode\n(hex)\nAvailable on:\n6502 65C02 65802/816\n# 0 /\nBytes\n# o /\nCycles\nProgram Counter Relative BCS nearlabel\n(or BGE nearlabel)\nBO X X  X 2 2 1 2\n1 Add 1 cycle if branch is taken\n2 Add 1 more cycle if branch taken crosses page boundary on 6502, 65C02, or 65816/65802's 6502 emulation mode\n(e = 1 )" },
    OpcodeDocInfo{ "BEQ", "Branch if Equal", "The zero flag in the P status register is tested. If it is set, meaning that the last\nvalue tested (which affected the zero flag) was zero, a branch is taken; if it is clear,\nmeaning the value tested was non-zero, the instruction immediately following the\ntwo-byte BEQ instruction is executed.\nIf the branch is taken, a one-byte signed displacement, fetched from the second\nbyte of the instruction, is sign-extended to sixteen bits and added to the program\ncounter. Once the branch address has been calculated, the result is loaded into the\nprogram counter, transferring control to that location.\nThe allowable range of the displacement is   128 to +127 (from the instruction\nimmediately following the branch).\nBEQ may be used in several ways: to determine if the result of a comparison is\nzero (the two values compared are equal), for example, or if a value just loaded,\npulled, shifted, incremented or decremented is zero; or to determine if further oper\nations are needed in multi-precision arithmetic operations. Because testing for\nequality to zero does not require a previous comparison with zero, it is generally\nmost efficient for loop counters to count downwards, exiting when zero is reached.", "Flags Affected:\n-------------------", "Codes:\nAddressing Mode Syntax\nOpcode\n(hex)\nAvailable on:\n6502 65C02 65802/816\nn  of\nBytes\n# 0 /\nCycles\nProgram Counter Relative BEQ nearlabelF0 X X  X 2 2 1 , 2\n1 Add 1 cycle if branch is taken\n2 Add 1 more cycle if branch taken crosses page boundary on 6502, 65C02, or 65816/65802's 6502 emulation mode\n(e = 1 )" },
    OpcodeDocInfo{ "BIT", "Test Memory Bits against Accumulator", "BIT sets the P status register flags based on the result of two different operations,\nmaking it a dual-purpose instruction:\nFirst, it sets or clears the n flag to reflect the value of the high bit of the data\nlocated at the effective address specified by the operand, and sets or clears the v\nflag to reflect the contents of the next-to-highest bit of the data addressed.\nSecond, it logically ANDs the data located at the effective address with the con\ntents of the accumulator; it changes neither value, but sets the z flag if the result is\nzero, or clears it if the result is non-zero.\nBIT is usually used immediately preceding a conditional branch instruction: to\ntest a memory value's highest or next-to-highest bits; with a mask in the accumula\ntor, to test any bits of the memory operand; or with a constant as the mask (using\nimmediate addressing) or a mask in memory, to test any bits in the accumulator.\nAll of these tests are non-destructive of the data in the accumulator or in memory.\nWhen the BIT instruction is used with the immediate addressing mode, the n and v\nflags are unaffected.\n8-bit accumulator/memory (all processors): Data in memory is eight-bit; bit 7 is\nmoved into the n flag; bit 6 is moved into the v flag.\n16-bit accumulator/memory (65802/65816 only, m = 0): Data in memory is\nsixteen-bit: the low-order eight bits are located at the effective address; the high-\norder eight bits are located at the effective address plus one. Bit 15 is moved into\nthe n flag; bit 14 is moved into the v flag.", "Flags Affected: nv----z  - (Other than immediate addressing)\n------z  - (Immediate addressing only)\nn Takes value of most significant bit of memory data,\nv Takes value of next-to-highest bit of memory data,\nz Set if logical AND of memory and accumulator is zero; else\ncleared.", "Codes:\nAddressing Mode Syntax\nOpcode\n(hex) 6502\nAvailable on:\n65C02 65802/816\n#0/\nBytes\nit of\nCycles\nImmediate BIT ttconst89 X X 2* 2}\nAbsolute BIT addr 2C X X X 3 41\nDirect Page (DP) BIT dp 24 X X X 2 3U\nAbsolute Indexed,X BIT addr.X3C X X 3 4 1 . 3\nDP Indexed,X BIT dp,X 34 X X 2 41.2\n* Add 1 byte if m = 0 (16-bit memory/accumulator)\n1 Add 1 cycle if m = 0 (16-bit memory/accumulator)\n2 Add 1 cycle if low byte of Direct Page register is other than zero (DL< >0)\n3 Add 1 cycle if adding index crosses a page boundary" },
    OpcodeDocInfo{ "BMI", "Branch if Minus", "The negative flag in the P status register is tested. If it is set, the high bit of the\nvalue which most recently affected the n flag was set, and a branch is taken. A\nnumber with its high bit set may be interpreted as a negative two's-complement\nnumber, so this instruction tests, among other things, for the sign of two's-comple\nment numbers. If the negative flag is clear, the high bit of the value which most\nrecently affected the flag was clear, or, in the two's-complement system, was a pos\nitive number, and the instruction immediately following the two-byte BMI instruc\ntion is executed.\nIf the branch is taken, a one-byte signed displacement, fetched from the second\nbyte of the instruction, is sign-extended to sixteen bits and added to the program\ncounter. Once the branch address has been calculated, the result is loaded into the\nprogram counter, transferring control to that location.\nThe allowable range of the displacement is -  128 to + 127 (from the instruction\nimmediately following the branch).\nBMI is primarily used to either determine, in two's-complement arithmetic, if a\nvalue is negative or, in logic situations, if the high bit of the value is set. It can also\nbe used when looping down through zero (the loop counter must have a positive\ninitial value) to determine if zero has been passed and to effect an exit from the\nloop.", "Flags Affected:\n-------------------", "Codes:\nAddressing Mode Syntax\nOpcode\n(hex)\nAvailable on:\n6502 65C02 65802/816\nn of\nBytes\nU of\nCycles\nProgram Counter Relative BMI nearlabel30 X X  X 2 21 , 2\n1 Add 1 cycle if branch is taken\n2 Add 1 more cycle if branch taken crosses page boundary on 6502, 65C02, or 65816/65802's 6502 emulation mode\n(e = 1 )" },
    OpcodeDocInfo{ "BNE", "Branch if Not Equal", "The zero flag in the P status register is tested. If it is clear (meaning the value just\ntested is non-zero), a branch is taken; if it is set (meaning the value tested is zero),\nthe instruction immediately following the two-byte BNE instruction is executed.\nIf the branch is taken, a one-byte signed displacement, fetched from the second\nbyte of the instruction, is sign-extended to sixteen bits and added to the program\ncounter. Once the branch address has been calculated, the result is loaded into the\nprogram counter, transferring control to that location.\nThe allowable range of the displacement is 128 to +127 (from the instruction\nimmediately following the branch).\nBNE may be used in several ways: to determine if the result of a comparison is\nnon-zero (the two values compared are not equal), for example, or if the value just\nloaded or pulled from the stack is non-zero, or to determine if further operations\nare needed in multi-precision arithmetic operations.", "Flags Affected:\n-------------------", "Codes:\nAddressing Mode Syntax\nOpcode\n(hex)\nAvailable on:\n6502 65C02 65802/816\nHof\nBytes\nHof\nCycles\nProgram Counter Relative BNE nearlabelDO X X  X 2 21.2\n1 Add 1 cycle if branch is taken\n2 Add 1 more cycle if branch taken crosses page boundary on 6502, 65C02, or 65816/65802's 6502 emulation mode\n(e = 1 )" },
    OpcodeDocInfo{ "BPL", "Branch if Plus", "The negative flag in the P status register is tested. If it is clearmeaning that the\nlast value which affected the zero flag had its high bit cleara branch is taken. In\nthe two's-complement system, values with their high bit clear are interpreted as\npositive numbers. If the flag is set, meaning the high bit of the last value was set,\nthe branch is not taken; it is a two's-complement negative number, and the instruc\ntion immediately following the two-byte BPL instruction is executed.\nIf the branch is taken, a one-byte signed displacement, fetched from the second\nbyte of the instruction, is sign-extended to sixteen bits and added to the program\ncounter. Once the branch address has been calculated, the result is loaded into the\nprogram counter, transferring control to that location.\nThe allowable range of the displacement is 128 to -I-127 (from the instruction\nimmediately following the branch).\nBPL is used primarily to determine, in two's-complement arithmetic, if a value is\npositive or not or, in logic situations, if the high bit of the value is clear.", "Flags Affected: -------------------", "Codes:\nAddressing Mode Syntax\nOpcode\n(hex)\nAvailable on:\n6502 65C02 65802/816\n#o/\nBytes\n# of\nCycles\nProgram Counter Relative BPL nearlabel10 X X  X 2 21,2\n1 Add 1 cycle if branch is taken\n2 Add 1 more cycle if branch taken crosses page boundary on 6502, 65C02, or 65816/65802's 6502 emulation mode\n(e = 1 )" },
    OpcodeDocInfo{ "BRA", "Branch Always", "A branch is always taken, and no testing is done: in effect, an unconditional JMP\nis executed, but since signed displacements are used, the instruction is only two\nbytes, rather than the three bytes of a JMP. Additionally, using displacements from\nthe program counter makes the BRA instruction relocatable. Unlike a JMP instruc\ntion, the BRA is limited to targets that lie within the range of the one-byte signed\ndisplacement of the conditional branches:   128 to + 127 bytes from the first byte\nfollowing the BRA instruction.\nTo branch, a one-byte signed displacement, fetched from the second byte of the\ninstruction, is sign-extended to sixteen bits and added to the program counter.\nOnce the branch address has been calculated, the result is loaded into the program\ncounter, transferring control to that location.", "Flags Affected:\n-------------------", "Codes:\nOpcode Available on:# of # of\nAddressing Mode Syntax (hex) 6502 65C02 65802/816 Bytes Cycles\nProgram Counter Relative BRA nearlabel80 X X 2 3\n1 Add 1 cycle if branch crosses page boundary on 65C02 or in 65816/65802's 6502 emulation mode (e = 1)" },
    OpcodeDocInfo{ "BRK", "similar to LIST, and additionally sets up the  vectors, so they can", nullptr, nullptr, nullptr },
    OpcodeDocInfo{ "BRL", "Branch Always Long", "A branch is always taken, similar to the BRA instruction. However, BRL is a\nthree-byte instruction; the two bytes immediately following the opcode form a\nsixteen-bit signed displacement from the program counter. Once the branch address\nhas been calculated, the result is loaded into the program counter, transferring con\ntrol to that location.\nThe allowable range of the displacement is anywhere within the current 64K pro\ngram bank.\nThe long branch provides an unconditional transfer of control similar to the JMP\ninstruction, with one major advantage: the branch instruction is relocatable while\njump instructions are not. However, the (non-relocatable) jump absolute instruc\ntion executes one cycle faster.", "Flags Affected: -------------------", "Codes:\nAddressing Mode Syntax\nOpcode\n(hex)\nAvailable on:\n6502 65C02 65802/816\n#0/\nBytes\n#0/\nCycles\nProgram Counter Relative Long BRL label 82 X 3 4" },
    OpcodeDocInfo{ "BVC", "Branch if Overflow Clear", "The overflow flag in the P status register is tested. If it is clear, a branch is taken;\nif it is set, the instruction immediately following the two-byte BVC instruction is\nexecuted.\nIf the branch is taken, a one-byte signed displacement, fetched from the second\nbyte of the instruction, is sign-extended to sixteen bits and added to the program\ncounter. Once the branch address has been calculated, the result is loaded into the\nprogram counter, transferring control to that location.\nThe allowable range of the displacement is 128 to -1-127 (from the instruction\nimmediately following the branch).\nThe overflow flag is altered by only four instructions on the 6502 and 65C02\naddition, subtraction, the CLV clear-the-flag instruction, and the BIT bit-testing\ninstruction. In addition, all the flags are restored from the stack by the PLP and\nRTI instructions. On the 65802/65816, however, the SEP and REP instructions can\nalso modify the v flag.\nBVC is used almost exclusively to check that a two's-complement arithmetic cal\nculation has not overflowed, much as the carry is used to determine if an unsigned\narithmetic calculation has overflowed. (Note, however, that the compare instruc\ntions do not affect the overflow flag.) You can also use BVC to test the second\nhighest bit in a value by using it after the BIT instruction, which moves the second-\nhighest bit of the tested value into the v flag.\nThe overflow flag can also be set by the Set Overflow hardware signal on the\n6502, 65C02, and 65802; on many systems, however, there is no connection to this\npin.", "Flags Affected: -------------------", "Codes:\nAddressing Mode Syntax\nOpcode\n(hex)\nAvailable on:\n6502 65C02 65802/816\nn of\nBytes\n# of\nCycles\nProgram Counter Relative BVC nearlabel50 XX X 2 212\n1 Add 1 cycle if branch is taken\n2 Add 1 more cycle if branch taken crosses page boundary on 6502, 65C02, or 65816/65802's 6502 emulation mode\n(e = 1 )" },
    OpcodeDocInfo{ "BVS", "Branch if Overflow Set", "The overflow flag in the P status register is tested. If it is set, a branch is taken; if\nit is clear, the instruction immediately following the two-byte BVS instruction is\nexecuted.\nIf the branch is taken, a one-byte signed displacement, fetched from the second\nbyte of the instruction, is sign-extended to sixteen bits and added to the program\ncounter. Once the branch address has been calculated, the result is loaded into the\nprogram counter, transferring control to that location.\nThe allowable range of the displacement is 128 to + 127 (from the instruction\nimmediately following the branch).\nThe overflow flag is altered by only four instructions on the 6502 and 65C02\naddition, subtraction, the CLV clear-the-flag instruction, and the BIT bit-testing\ninstruction. In addition, all the flags are restored from the stack by the PLP and\nRTI instructions. On the 65802/65816, the SEP and REP instructions can also mod\nify the v flag.\nBVS is used almost exclusively to determine if a two's-complement arithmetic\ncalculation has overflowed, much as the carry is used to determine if an\nunsigned arithmetic calculation has overflowed. (Note, however, that the compare\ninstructions do not affect the overflow flag.) You can also use BVS to test the\nsecond-highest bit in a value by using it after the BIT instruction, which moves the\nsecond-highest bit of the tested value into the v flag.\nThe overflow flag can also be set by the Set Overflow hardware signal on the\n6502, 65C02, and 65802; on many systems, however, there is no hardware connec\ntion to this signal.", "Flags Affected: -------------------", "Codes:\nAddressing Mode Syntax\nOpcode Available on:\n(hex) 6502 65C02 65802/816\nHof\nBytes\nHof\nCycles\nProgram Counter Relative BVS nearlabel70 x x x 2 21-2\n1 Add 1 cycle if branch is taken\n2 Add 1 more cycle if branch taken crosses page boundary on 6502, 65C02, or 65816/65802's 6502 emulation mode\n(e = 1 )" },
    OpcodeDocInfo{ "CLC", "Clear Carry Flag", "Clear the carry flag in the status register.\nCLC is used prior to addition (using the 65x's ADC instruction) to keep the carry\nflag from affecting the result; prior to a BCC (branch on carry clear) instruction on\nthe 6502 to force a branch-always; and prior to an XCE (exchange carry flag with\nemulation bit) instruction to put the 65802 or 65816 into native mode.", "Flags Affected: -----------------c\nc carry flag cleared always.", "Codes:\nAddressing Mode Syntax\nOpcode\n(hex)\nAvailable on:\n6502 65C02 65802/816\n#0/\nBytes\n#0/\nCycles\nImplied CLC 18 XX X 1 2" },
    OpcodeDocInfo{ "CLD", "Clear Decimal Mode Flag", "Clear the decimal mode flag in the status register.\nCLD is used to shift 65x processors back into binary mode from decimal mode,\nso that the ADC and SBC instructions will correctly operate on binary rather than\nBCD data.", "Flags Affected:  d-------\nd decimal mode flag cleared always.", "Codes:\nOpcode Available on:# 0 /  # 0 /\nAddressing Mode Syntax (hex) 6502 65C02 65802/816 Bytes Cycles\nImplied CLD D 8 X X  X 1  2" },
    OpcodeDocInfo{ "CLI", "Clear Interrupt Disable Flag", "Clear the interrupt disable flag in the status register.\nCLI is used to re-enable hardware interrupt (IRQ) processing. (When the i bit is\nset, hardware interrupts are ignored.) The processor itself sets the i flag when it\nbegins servicing an interrupt, so interrupt handling routines must re-enable inter\nrupts with CLI if the interrupt-service routine is designed to service interrupts that\noccur while a previous interrupt is still being handled; otherwise, the RTI instruc\ntion will restore a clear i flag from the stack, and CLI is not necessary. CLI is also\nused to re-enable interrupts if they have been disabled during the execution of\ntime-critical or other code which cannot be interrupted.", "Flags Affected:----------------i \ni interrupt disable flag cleared always.", "Codes:\nAddressing Mode Syntax\nOpcode\n(hex)\nAvailable on:\n6502 65C02 65802/816\nn of\nBytes\n# o /\nCycles\nImplied CLI 58 XX X 1 2" },
    OpcodeDocInfo{ "CLV", "Clear Overflow Flag", "Clear the overflow flag in the status register.\nCLV is sometimes used prior to a BVC (branch on overflow clear) to force a\nbranch-always on the 6502. Unlike the other clear flag instructions, there is no\ncomplementary \"set flag\" instruction to set the overflow flag, although the over\nflow flag can be set by hardware via the Set Overflow input pin on the processor.\nThis signal, however, is often unconnected. The 65802/65816 REP instruction can,\nof course, clear the overflow flag; on the 6502 and 65C02, a BIT instruction with a\nmask in memory that has bit 6 set can be used to set the overflow flag.", "Flags Affected: - v\n---------------\nv overflow flag cleared always.", "Codes:\nAddressing Mode Syntax\nOpcode\n(hex)\nAvailable on:\n6502 65C02 65802/816\nIt of\nBytes\n* of\nCycles\nImplied CLV B 8 XX X 1 2" },
    OpcodeDocInfo{ "CMP", "Compare Accumulator with Memory", "Subtract the data located at the effective address specified by the operand from\nthe contents of the accumulator, setting the carry, zero, and negative flags based on\nthe result, but without altering the contents of either the memory location or the\naccumulator. That is, the result is not saved. The comparison is of unsigned binary\nvalues only.\nThe CMP instruction differs from the SBC instruction in several ways. First, the\nresult is not saved. Second, the value in the carry prior to the operation is irrele\nvant to the operation; that is, the carry does not have to be set prior to a compare\nas it is with 65x subtractions. Third, the compare instruction does not set the over\nflow flag, so it cannot be used for signed comparisons. Although decimal mode\ndoes not affect the CMP instruction, decimal comparisons are effective, since the\nequivalent binary values maintain the same magnitude relationships as the decimal\nvalues have, for example, $99 > $04 just as 99 > 4.\nThe primary use for the compare instruction is to set the flags so that a condi\ntional branch can then be executed.\n8-bit accumulator (all processors); Data compared is eight-bit.\n16-bit accumulator (65802/65816 only, m = 0): Data compared is sixteen-bit: the\nlow-order eight bits of the data in memory are located at the effective address; the\nhigh-order eight bits are located at the effective address plus one.", "Flags Affected: n", nullptr },
    OpcodeDocInfo{ "COP", "essing, such as by a floating point processor. When the  instruction", nullptr, nullptr, nullptr },
    OpcodeDocInfo{ "CPX", "Compare Index Register X with Memory", "Subtract the data located at the effective address specified by the operand from\nthe contents of the X register, setting the carry, zero, and negative flags based on\nthe result, but without altering the contents of either the memory location or the\nregister. The result is not saved. The comparison is of unsigned values only (except\nfor signed comparison for equality).\nThe primary use for the CPX instruction is to test the value of the X index regis\nter against loop boundaries, setting the flags so that a conditional branch can be\nexecuted.\n8-bit index registers (all processors): Data compared is eight-bit.\n16-bit index registers (65802/65816 only, x = 0): Data compared is sixteen-bit:\nthe low-order eight bits of the data in memory are located at the effective address;\nthe high-order eight bits are located at the effective address plus one.", "Flags Affected: n\n--------------zc\nn Set if most significant bit of result is set; else cleared.\nz Set if result is zero; else cleared.\nc Set if no borrow required (X register value higher or same);\ncleared if borrow required (X register value lower).", "Codes:\nAddressing Mode Syntax\nOpcode\n(hex)6502\nAvailable on:\n65C02 65802/816\nU of\nBytes\n# 0 /\nCycles\nImmediate CPX ttconstE0 X X  X 2* 2'\nAbsolute CPX addr EC X X  X 3 41\nDirect Page (also DP) CPX dp E4 X X  X 2 312\nAdd 1 byte if x = 0 (16-bit index registers)\n1 Add 1 cycle if x = 0 (16-bit index registers)\n2 Add 1 cycle if low byte of Direct Page register is other than zero (DL< >0)" },
    OpcodeDocInfo{ "CPY", "Compare Index Register Y with Memory", "Subtract the data located at the effective address specified by the operand from\nthe contents of the Y register, setting the carry, zero, and negative flags based on\nthe result, but without altering the contents of either the memory location or the\nregister. The comparison is of unsigned values only (except for signed comparison\nfor equality).\nThe primary use for the CPY instruction is to test the value of the Y index regis\nter against loop boundaries, setting the flags so that a conditional branch can be\nexecuted.\n8-bit index registers (all processors): Data compared is eight-bit.\n16-bit index registers (65802/65816 only, x = 0): Data compared is sixteen-bit:\nthe low-order eight bits of the data in memory is located at the effective address;\nthe high-order eight bits are located at the effective address plus one.", "Flags Affected: n--------------zc\nn Set if most significant bit of result is set; else cleared.\nz Set if result is zero; else cleared.\nc Set if no borrow required (Y register value higher or same);\ncleared if borrow required (Y register value lower).", "Codes:\nAddressing Mode+ + Syntax\nOpcode\n(hex) 6502\nAvailable on:\n65C02 65802/816\nn of\nBytes\nHof\nCycles\nImmediate CPY ttconstCO X X  X 2* 21\nAbsolute CPY addr CC X X  X 3 4 1\nDirect Page (also DP) CPY dp C4 X X  X 2 312\n* Add 1 byte if x = 0 (16-bit index registers)\n1 Add 1 cycle if x = 0 (16-bit index registers)\n2 Add 1 cycle if low byte of Direct Page register is other than zero (DL< >0)" },
    OpcodeDocInfo{ "DEC", "Decrement", "Decrement by one the contents of the location specified by the operand (subtract\none from the value).\nUnlike subtracting a one using the SBC instruction, the decrement instruction is\nneither affected by nor affects the carry flag. You can test for wraparound only by\ntesting after every decrement to see if the value is zero or negative. On the other\nhand, you don't need to set the carry before decrementing.\nDEC is unaffected by the setting of the d (decimal) flag.\n8-bit accumulator/memory (all processors): Data decremented is eight-bit.\n16-bit accumulator/memory (65802/65816 only, m = 0): Data decremented is\nsixteen-bit: if in memory, the low-order eight bits are located at the effective\naddress; the high-order eight bits are located at the effective address plus one.", "Flags Affected: n  z -\nn Set if most significant bit of result is set; else cleared,\nz Set if result is zero; else cleared.", "Codes:\nAddressing Mode Syntax\nOpcode\n(hex) 6502\nAvailable on:\n65C02 65802/816\n#o/\nBytes\n#o/\nCycles\nAccumulator DEC A 3A X  X 1 2\nAbsolute DEC addr CE X X  X 3 61\nDirect Page (also DP) DEC dp C 6 X X  X 2 51,2\nAbsolute Indexed,X DEC addr,X DE X X  X 3 71,3\nDP Indexed, X DEC dp,X D 6 X X  X 2 61,2\n1 Add 2 cycles if m = 0 (16-bit memory/accumulator)\n2 Add 1 cycle if low byte of Direct Page register is other than zero (DL< >0)\n3 Subtract 1 cycle if 65C02 and no page boundary crossed" },
    OpcodeDocInfo{ "DEX", "Decrement Index Register X", "Decrement by one the contents of index register X (subtract one from the value).\nThis is a special purpose, implied addressing form of the DEC instruction.\nUnlike using SBC to subtract a one from the value, the DEX instruction does not\naffect the carry flag; you can test for wraparound only by testing after every decre\nment to see if the value is zero or negative. On the other hand, you don't need to\nset the carry before decrementing.\nDEX is unaffected by the setting of the d (decimal) flag.\n8-bit index registers (all processors): Data decremented is eight-bit.\n16-bit index registers (65802/65816 only, x = 0): Data decremented is sixteen-bit.", "Flags Affected: n--------------z -\nn Set if most significant bit of result is set; else cleared,\nz Set if result is zero; else cleared.", "Codes:\nAddressing Mode Syntax\nOpcode\n(hex)\nAvailable on:\n6502 65C02 65802/816\n# 0 /\nBytes\n# of\nCycles\nImplied DEX CA X X  X 1 2" },
    OpcodeDocInfo{ "DEY", "Decrement Index Register Y", "Decrement by one the contents of index register Y (subtract one from the value).\nThis is a special purpose, implied addressing form of the DEC instruction.\nUnlike using SBC to subtract a one from the value, the DEY instruction does not\naffect the carry flag; you can test for wraparound only by testing after every decre\nment to see if the value is zero or negative. On the other hand, you don't need to\nset the carry before decrementing.\nDEY is unaffected by the setting of the d (decimal) flag.\n8-bit index registers (all processors): Data decremented is eight-bit.\n16-bit index registers (65802/65816 only, x = 0): Data decremented is sixteen-bit.", "Flags Affected: n z -\nn Set if most significant bit of result is set; else cleared,\nz Set if result is zero; else cleared.", "Codes:\nAddressing Mode Syntax\nOpcode\n(hex)\nAvailable on:\n6502 65C02 65802/816\n# 0 /\nBytes\nn of\nCycles\nImplied DEY 8 8 X X  X 1 2" },
    OpcodeDocInfo{ "EOR", "Exclusive-OR Accumulator with Memory", "Bitwise logical Exclusive-OR the data located at the effective address specified by\nthe operand with the contents of the accumulator. Each bit in the accumulator is\nexclusive-ORed with the corresponding bit in memory, and the result is stored into\nthe same accumulator bit.\nThe truth table for the logical exclusive-OR operation is:\nSeco n d  O perand\n0 1\nFirst O perand\n0 0 1\n1 1 0\nFigure 18.5. Exclusive OR Truth Table.\nA 1 or logical true results only if the two elements of the Exclusive-OR operation\nare different.\n8-bit accumulator (all processors): Data exclusive-ORed from memory is eight-\nbit.\n16-bit accumulator (65802/65816 only, m = 0): Data exclusive-ORed from mem\nory is sixteen-bit: the low-order eight bits are located at the effective address; the\nhigh-order eight bits are located at the effective address plus one.", "Flags Affected: n", nullptr },
    OpcodeDocInfo{ "INC", "Increment", "Increment by one the contents of the location specified by the operand (add one\nto the value).\nUnlike adding a one with the ADC instruction, however, the increment instruc\ntion is neither affected by nor affects the carry flag. You can test for wraparound\nonly by testing after every increment to see if the result is zero or positive. On the\nother hand, you don't have to clear the carry before incrementing.\nThe INC instruction is unaffected by the d (decimal) flag.\n8-bit accumulator/memory (all processors): Data incremented is eight-bit.\n16-bit accumulator/memory (65802/65816 only, m = 0): Data incremented is\nsixteen-bit: if in memory, the low-order eight bits are located at the effective\naddress; the high-order eight-bits are located at the effective address plus one.", "Flags Affected: n z -\nn Set if most significant bit of result is set; else cleared,\nz Set if result is zero; else cleared.", "Codes:\nAddressing Mode Syntax\nOpcode\n(hex) 6502\nAvailable on:\n65C02 65802/816\n# 0 /\nBytes\nIt of\nCycles\nAccumulator INC A 1A X X 1 2\nAbsolute INC addr EE X X X 3 61\nDirect Page (also DP) INC dp E6 X X X 2 51,2\nAbsolute Indexed,X 1UC addr,X FE X X X 3 y l , 3\nDP Indexed,X INC dp,X F6 X X X 2 61,2\n1 Add 2 cycles if m = 0 (16-bit memory/accumulator)\n2 Add 1 cycle if low byte of Direct Page register is other than zero (DL< >0)\n3 Subtract 1 cycle if 65C02 and no page boundary crossed" },
    OpcodeDocInfo{ "INX", "Increment Index Register X", "Increment by one the contents of index register X (add one to the value). This is a\nspecial purpose, implied addressing form of the INC instruction.\nUnlike using ADC to add a one to the value, the INX instruction does not affect\nthe carry flag. You can execute it without first clearing the carry. But you can test\nfor wraparound only by testing after every increment to see if the result is zero or\npositive. The INX instruction is unaffected by the d (decimal) flag.\n8-bit index registers (all processors): Data incremented is eight-bit.\n16-bit index registers (65802/65816 only, x = 0): Data incremented is sixteen-bit.", "Flags Affected: n-------------z -\nn Set if most significant bit of result is set; else cleared,\nz Set if result is zero; else cleared.", "Codes:\nAddressing Mode Syntax\nOpcode\n(hex)\nAvailable on:\n6502 65C02 65802/816\n# 0 /\nBytes\nn of\nCycles\nImplied INX E8 X X  X 1 2" },
    OpcodeDocInfo{ "INY", "Increment Index Register Y", "Increment by one the contents of index register Y (add one to the value). This is a\nspecial purpose, implied addressing form of the INC instruction.\nUnlike using ADC to add one to the value, the INY instruction does not affect\nthe carry flag. You can execute it without first clearing the carry. But you can test\nfor wraparound only by testing after every increment to see if the value is zero or\npositive. The INY instruction is unaffected by the d (decimal) flag.\n8-bit index registers (all processors): Data incremented is eight-bit.\n16-bit index registers (65802/65816 only, x = 0): Data incremented is sixteen-bit.", "Flags Affected: n  z -\nn Set if most significant bit of result is set; else cleared,\nz Set if result is zero; else cleared.", "Codes:\nAddressing Mode Syntax\nOpcode\n(hex)\nAvailable on:\n6502 65C02 65802/816\n# of\nBytes\nn of\nCycles\nImplied INY C 8 XX X 1 2" },
    OpcodeDocInfo{ "JMP", "Jump", "Transfer control to the address specified by the operand field.\nThe program counter is loaded with the target address. If a long JMP is executed,\nthe program counter bank is loaded from the third byte of the target address speci\nfied by the operand.", "Flags Affected: -------------------", "Codes:\nAddressing Mode+ + Syntax\nOpcode\n(hex)\nAvailable on:\n6502 65C02 65802/816\n# of\nBytes\n# of\nCycles\nAbsolute JMP addr 4C X X  X 3 3\nAbsolute Indirect JMP (addr) 6C X X  X 3 51,2\nAbsolute Indexed Indirect JMP (addr.X)7C X  X 3 6\nAbsolute Long JMP long\n(or JML long)\n5C X 4 4\nAbsolute Indirect Long JMP [addr]\n(or JML [addr])\nDC X 3 6\n1 Add 1 cycle if 65C02\n2 6502: If low byte of addr is $FF (i.e., addr is SxxFF): yields incorrect result" },
    OpcodeDocInfo{ "JSL", "Jump to Subroutine Long (Inter-Bank)", "Jump-to-subroutine with long (24-bit) addressing: transfer control to the subrou\ntine at the 24-bit address which is the operand, after first pushing a 24-bit (long)\nreturn address onto the stack. This return address is the address of the last instruc\ntion byte (the fourth instruction byte, or the third operand byte), not the address of\nthe next instruction; it is the return address minus one.\nThe current program counter bank is pushed onto the stack first, then the high-\norder byte of the return address and then the low-order byte of the address are\npushed on the stack in standard 65x order (low byte in the lowest address, bank\nbyte in the highest address). The stack pointer is adjusted after each byte is pushed\nto point to the next lower byte (the next available stack location). The program\ncounter bank register and program counter are then loaded with the operand val\nues, and control is transferred to the specified location.", "Flags Affected:\n-------------------", "Codes:\nAddressing Mode Syntax\nOpcode Available to:\n(hex) 6502 65C02 65802/816\nnof Hof\nBytes Cycles\nAbsolute Long JSL  long\n(or JSR long)\n22 x 4 8" },
    OpcodeDocInfo{ "JSR", "Jump to Subroutine", "Transfer control to the subroutine at the location specified by the operand, after\nfirst pushing onto the stack, as a return address, the current program counter\nvalue, that is, the address of the last instruction byte (the third byte of a three-byte\ninstruction, the fourth byte of a four-byte instruction), not the address of the next\ninstruction.\nIf an absolute operand is coded and is less than or equal to $FFFF, absolute\naddressing is assumed by the assembler; if the value is greater than $FFFF, absolute\nlong addressing is used.\nIf long addressing is used, the current program counter bank is pushed onto the\nstack first. Nextor first in the more normal case of intra-bank addressingthe\nhigh order byte of the return address is pushed, followed by the low order byte.\nThis leaves it on the stack in standard 65x order (lowest byte at the lowest address,\nhighest byte at the highest address). After the return address is pushed, the stack\npointer points to the next available location (next lower byte) on the stack. Finally,\nthe program counter (and, in the case of long addressing, the program counter\nbank register) is loaded with the values specified by the operand, and control is\ntransferred to the target location.", "Flags Affected: -------------------", "Codes:\nAddressing Mode Syntax\nOpcode\n(hex)\nAvailable to:\n6502 65C02 65802/816\n# 0 /  # 0 /\nBytes Cycles\nAbsolute JSR addr 2 0 XX X 3 6\nAbsolute Indexed Indirect JSR (addr.X) FC X 3 8\nAbsolute Long JSR long\n(or JSL  long)\n2 2 X 4 8" },
    OpcodeDocInfo{ "LDA", "Load Accumulator from Memory", "Load the accumulator with the data located at the effective address specified by\nthe operand.\n8-bit accumulator (all processors): Data is eight-bit.\n16-bit accumulator (65802/65816 only, m = 0): Data is sixteen-bit; the low-order\neight bits are located at the effective address; the high-order eight bits are located at\nthe effective address plus one.", "Flags Affected: n  z -\nn Set if most significant bit of loaded value is set; else cleared,\nz Set if value loaded is zero; else cleared.", "Codes:\nAddressing Mode* * Syntax\nOpcode\n(hex) 6502\nAvailable to:\n65C02 65802/816\n#o/\nBytes\nHof\nCycles\nImmediate LDA UconstA9 X X X 2* 2)\nAbsolute LDA addr AD X X X 3 4 1\nAbsolute Long LDA long AF X 4 5 1\nDirect Page (also DP) LDA dp A5 X X X 2 31,2\nDP Indirect LDA (dp) B2 X X 2 51-2\nDP Indirect Long LDA [dp] A 7 X 2 61,2\nAbsolute Indexed,X LDA addr,XBD X X X 3 41.3\nAbsolute Long Indexed,X LDA long,XBF X 4 5 1\nAbsolute Indexed, Y LDA addr,Y B9 X X X 3 41.3\nDP Indexed,X LDA dp,X B5 X X X 2 41.2\nDP Indexed Indirect,X LDA (dp,X) A1 X X X 2 6 1 , 2\nDP Indirect Indexed,Y LDA (dp),Y Bl X X X 2 5U .3\nDP Indirect Long Indexed,Y LDA [dp],Y B7 X 2 6 1 , 2\nStack Relative (also SR) LDA sr,S A3 X 2 41\nSR Indirect Indexed,Y LDA (sr,S),Y B3 X 2 71\n+ +LDA, a Primary Group Instruction, has available all of the Primary Group addressing modes and bit patterns\n* Add 1 byte if m = 0 (16-bit memory/accumulator)\n1 Add 1 cycle if m = 0 (16-bit memory/accumulator)\n2 Add 1 cycle if low byte of Direct Page register is other than zero (DL< >0)\n3 Add 1 cycle if adding index crosses a page boundary" },
    OpcodeDocInfo{ "LDX", "Load Index Register X from Memory", "Load index register X with the data located at the effective address specified by\nthe operand.\n8-bit index registers (all processors): Data is eight-bit.\n16-bit index registers (65802/65816 only, x = 0): Data is sixteen-bit: the low-\norder eight bits are located at the effective address; the high-order eight bits are\nlocated at the effective address plus one.", "Flags Affected: n  z -\nn Set if most significant bit of loaded value is set; else cleared,\nz Set if value loaded is zero; else cleared.", "Codes:\nAddressing Mode Syntax\nOpcode\n(hex)6502\nAvailable to:\n65C02 65802/816\n#0/\nBytes\n# of\nCycles\nImmediate LDX ttconstA2 X X X 2* 2}\nAbsolute LDX addr AE X X X 3 4 1\nDirect Page (also DP) LDX dp A 6 X X X 2 3U\nAbsolute Indexed,Y LDX addr,Y BE X X X 3 4 1 . 3\nDP Indexed,Y LDX dp,Y B6 X X X 2 41.2\nAdd 1 byte if x = 0 (16-bit index registers)\n1 Add 1 cycle if x = 0 (16-bit index registers)\n2 Add 1 cycle if low byte of Direct Page register is other than zero (DL < > 0)\n3 Add 1 cycle if adding index crosses a page boundary" },
    OpcodeDocInfo{ "LDY", "Load Index Register Y from Memory", "Load index register Y with the data located at the effective address specified by\nthe operand.\n8-bit index registers (all processors): Data is eight-bit.\n16-bit index registers (65802/65816 only, x = 0): Data is sixteen-bit: the low-\norder eight bits are located at the effective address; the high-order eight bits are\nlocated at the effective address plus one.", "Flags Affected: n  z -\nn Set if most significant bit of loaded value is set; else cleared,\nz Set if value loaded is zero; else cleared.", "Codes:\nAddressing Mode Syntax\nOpcode\n(hex)6502\nAvailable to:\n65C02 65802/816\nHof\nBytes\nHof\nCycles\nImmediate LDY Hconst AO x X X 2* 21\nAbsolute LDY addr AC X X X 3 41\nDirect Page (also DP) LDY dp A4 X X X 2 3U\nAbsolute Indexed, X LDY addr,X BC X X X 3 41.3\nDP Indexed,X LDY dp,X B4 X X X 2 41.2\n* Add 1 byte if x = 0 (16-bit index registers)\n1 Add 1 cycle if x = 0 (16-bit index registers)\n2 Add 1 cycle if low byte of Direct Page register is other than zero (DL< >0)\n3 Add 1 cycle if adding index crosses a page boundary" },
    OpcodeDocInfo{ "LSR", "Logical Shift Memory or Accumulator Right", "Logical shift the contents of the location specified by the operand right one bit.\nThat is, bit zero takes on the value originally found in bit one, bit one takes the\nvalue originally found in bit two, and so on; the leftmost bit (bit 7 if the m memory\nselect flag is one when the instruction is executed or bit 15 if it is zero) is cleared;\nthe rightmost bit, bit zero, is transferred to the carry flag. This is the arithmetic\nequivalent of unsigned division by two.\nr r m n n r\nCarry Flag\nFigure 18.6. LSR.\n8-bit accumulator/memory (all processors): Data shifted is eight-bit.\n16-bit accumulator/memory (65802/65816 only, m = 0): Data shifted is sixteen-\nbit: if in memory, the low-order eight bits are located at the effective address; the\nhigh-order eight bits are located at the effective address plus one.", "Flags Affected: n--------------zc\nn Cleared.\nz Set if result is zero; else cleared.\nc Low bit becomes carry: set if low bit was set; cleared if low bit was\nzero.", "Codes:\nAddressing Mode Syntax\nOpcode\n(hex) 6502\nAvailable to:\n65C02 65802/816\n#o/\nBytes\n#o/\nCycles\nAccumulator LSR A 4A X X X 1 2\nAbsolute LSR addr 4E X X X 3 61\nDirect Page (also DP) LSR dp 46 X X X 2 51,2\nAbsolute Indexed,X LSR addr,X 5E X X X 3 71.3\nDP Indexed,X LSR dp,X 56 X X X 2 61 2\n1 Add 2 cycles if m = 0 (16-bit memory/accumulator)\n2 Add 1 cycle if low byte of Direct Page register is other than zero (DL< >0)\n3 Subtract 1 cycle if 65C02 and no page boundary crossed" },
    OpcodeDocInfo{ "MVN", "the mnemonic table are copied into the output line using the", nullptr, nullptr, nullptr },
    OpcodeDocInfo{ "MVP", "The  instruction assumes X and Y specify the top (or ending)", nullptr, nullptr, nullptr },
    OpcodeDocInfo{ "NOP", "No Operation", "Executing a NOP takes no action; it has no effect on any 65x registers or mem\nory, except the program counter, which is incremented once to point to the next\ninstruction.\nIts primary uses are during debugging, where it is used to \"patch out\" unwanted\ncode, or as a place-holder, included in the assembler source, where you anticipate\nyou may have to \"patch in\" instructions, and want to leave a \"hole\" for the patch.\nNOP may also be used to expand timing loopseach NOP instruction takes two\ncycles to execute, so adding one or more may help fine tune a timing loop.", "Flags Affected: -------------------", "Codes:\nAddressing Mode Syntax\nOpcode\n(hex)\nAvailable to:\n6502 65C02 65802/816\n# 0 /\nBytes\nIt of\nCycles\nImplied NOP EA X X  X 1 2" },
    OpcodeDocInfo{ "ORA", "OR Accumulator with Memory", "Bitwise logical OR the data located at the effective address specified by the oper\nand with the contents of the accumulator. Each bit in the accumulator is ORed with\nthe corresponding bit in memory. The result is stored into the same accumulator\nbit.\nThe truth table for the logical OR operation is:\nSecond Operand\n0 1\nFirst Operand\n0 0 1\n1 1 1\nFigure 18.7. Logical OR Truth Table.\nA 1 or logical true results if either of the two operands of the OR operation is\ntrue.\n8-bit accumulator (all processors): Data ORed from memory is eight-bit.\n16-bit accumulator (65802/65816 only, m = 0): Data ORed from memory is\nsixteen-bit: the low-order eight bits are located at the effective address; the high-\norder eight bits are located at the effective address plus one.", "Flags Affected: n", nullptr },
    OpcodeDocInfo{ "PEA", "Push Effective Absolute Address", "Push the sixteen-bit operand (typically an absolute address) onto the stack. The\nstack pointer is decremented twice. This operation always pushes sixteen bits of\ndata, irrespective of the settings of the m and x mode select flags.\nAlthough the mnemonic suggests that the sixteen-bit value pushed on the stack\nbe considered an address, the instruction may also be considered a \"push sixteen-bit\nimmediate data\" instruction, although the syntax of immediate addressing is not\nused. The assembler syntax is that of the absolute addressing mode, that is, a label\nor sixteen-bit value in the operand field. Unlike all other instructions that use this\nassembler syntax, the effective address itself, rather than the data stored at the\neffective address, is what is accessed (and in this case, pushed onto the stack).", "Flags Affected: -------------------", "Codes:\nAddressing Mode Syntax\nOpcode\n(hex)\nAvailable to:\n6502 65C02 65802/816\n# 0 /\nBytes\n# of\nCycles\nStack (Absolute) PEA addr F4 X 3 5" },
    OpcodeDocInfo{ "PEI", "Push Effective Indirect Address", "Push the sixteen-bit value located at the address formed by adding the direct\npage offset specified by the operand to the direct page register. The mnemonic\nimplies that the sixteen-bit data pushed is considered an address, although it can be\nany sixteen-bit data. This operation always pushes sixteen bits of data, irrespective\nof the settings of the m and x mode select flags.\nThe first byte pushed is the byte at the direct page offset plus one (the high byte\nof the double byte stored at the direct page offset). The byte at the direct page off\nset itself (the low byte) is pushed next. The stack pointer now points to the next\navailable stack location, directly below the last byte pushed.\nThe assembler syntax is that of direct page indirect; however, unlike other\ninstructions which use this assembler syntax, the effective indirect address, rather\nthan the data stored at that address, is what is accessed and pushed onto the stack.", "Flags Affected:\n-------------------", "Codes:\nAddressing ModeSyntax\nOpcode Available to:\n(hex) 6502 65C02 65802/816\n#o/\nBytes\nU of\nCycles\nStack (Direct Page Indirect) PEI (dp) D4 x 2 61\n1 Add 1 cycle if low byte of Direct Page register is other than zero (DL< >0)" },
    OpcodeDocInfo{ "PER", "Push Effective PC Relative Indirect Address", "Add the current value of the program counter to the sixteen-bit signed displace\nment in the operand, and push the result on the stack. This operation always\npushes sixteen bits of data, irrespective of the settings of the m and x mode select\nflags.\nThe high byte of the sum is pushed first, then the low byte is pushed. After the\ninstruction is completed, the stack pointer points to the next available stack loca\ntion, immediately below the last byte pushed.\nBecause PER's operand is a displacement relative to the current value of the pro\ngram counter (as with the branch instructions), this instruction is helpful in writing\nself-relocatable code in which an address within the program (typically of a data\narea) must be accessed. The address pushed onto the stack will be the run-time\naddress of the data area, regardless of where the program was loaded in memory; it\nmay be pulled into a register, stored in an indirect pointer, or used on the stack\nwith the stack relative indirect indexed addressing mode to access the data at that\nlocation.\nAs is the case with the branch instructions, the syntax used is to specify as the\noperand the label of the data area you want to reference. This location must be in\nthe program bank, since the displacement is relative to the program counter. The\nassembler converts the assembly-time label into a displacement from the assembly\ntime address of the next instruction.\nThe value of the program counter used in the addition is the address of the next\ninstruction, that is, the instruction following the PER instruction.\nPER may also be used to push return addresses on the stack, either as part of a\nsimulated branch-to-subroutine or to place the return address beneath the stacked\nparameters to a subroutine call; always remember that a pushed return address\nshould be the desired return address minus one.", "Flags Affected:\n-------------------", "Codes:\nAddressing Mode Syntax\nOpcode\n(hex)\nAvailable to:\n6502 65C02 65802/816\nHof\nBytes\nHof\nCycles\nStack (Program Counter Relative Long) PER label 62 X 3 6" },
    OpcodeDocInfo{ "PHA", "Push Accumulator", "Push the accumulator onto the stack. The accumulator itself is unchanged.\n8-bit accumulator (all processors): The single byte contents of the accumulator\nare pushedthey are stored to the location pointed to by the stack pointer and the\nstack pointer is decremented.\n16-bit accumulator (65802/65816 only, m = 0): Both accumulator bytes are\npushed. The high byte is pushed first, then the low byte. The stack pointer now\npoints to the next available stack location, directly below the last byte pushed.", "Flags Affected:\n-------------------", "Codes:\nOpcode Available to:# 0 / # of\nAddressing ModeSyntax (hex) 6502 65C02 65802/816 BytesCycles\nStack (Push) PHA 48 X X  X 1 31\n1 Add 1 cycle if m = 0 (16-bit memory/accumulator)" },
    OpcodeDocInfo{ "PHB", "Push Data Bank Register", "Push the contents of the data bank register onto the stack.\nThe single-byte contents of the data bank register are pushed onto the stack; the\nstack pointer now points to the next available stack location, directly below the\nbyte pushed. The data bank register itself is unchanged. Since the data bank regis\nter is an eight-bit register, only one byte is pushed onto the stack, regardless of the\nsettings of the m and x mode select flags.\nWhile the 65816 always generates 24-bit addresses, most memory references are\nspecified by a sixteen-bit address. These addresses are concatenated with the con\ntents of the data bank register to form a full 24-bit address. This instruction lets the\ncurrent value of the data bank register be saved prior to loading a new value.", "Flags Affected: -------------------", "Codes:\nAddressing Mode Syntax\nOpcode\n(hex)\nAvailable to:\n6502 65C02 65802/816\n# of\nBytes\nn of\nCycles\nStack (Push) PHB 8B X 1 3" },
    OpcodeDocInfo{ "PHD", "Push Direct Page Register", "Push the contents of the direct page register D onto the stack.\nSince the direct page register is always a sixteen-bit register, this is always a\nsixteen-bit operation, regardless of the settings of the m and x mode select flags.\nThe high byte of the direct page register is pushed first, then the low byte. The\ndirect page register itself is unchanged. The stack pointer now points to the next\navailable stack location, directly below the last byte pushed.\nBy pushing the D register onto the stack, the local environment of a calling sub\nroutine may easily be saved by a called subroutine before modifying the D register\nto provide itself with its own direct page memory.", "Flags Affected:\n-------------------", "Codes:\nAddressing Mode Syntax\nOpcode\n(hex)\nAvailable to:\n6502 65C02 65802/816\n# 0 /\nBytes\n# 0 /\nCycles\nStack (Push) PHD OB X 1 4" },
    OpcodeDocInfo{ "PHK", "Push Program Bank Register", "Push the program bank register onto the stack.\nThe single-byte contents of the program bank register are pushed. The program\nbank register itself is unchanged. The stack pointer now points to the next available\nstack location, directly below the byte pushed. Since the program bank register is\nan eight-bit register, only one byte is pushed onto the stack, regardless of the set\ntings of the m and x mode select flags.\nWhile the 65816 always generates 24-bit addresses, most jumps and branches\nspecify only a sixteen-bit address. These addresses are concatenated with the con\ntents of the program bank register to form a full 24-bit address. This instruction lets\nyou determine the current value of the program bank registerfor example, if you\nwant the data bank to be set to the same value as the program bank.", "Flags Affected:\n-------------------", "Codes:\nAddressing Mode Syntax\nOpcode\n(hex)\nAvailable to:\n6502 65C02 65802/816\n#0/\nBytes\n#0/\nCycles\nStack (Push) PHK 4B X 1 3" },
    OpcodeDocInfo{ "PHP", "Push Processr Status Register", "Push the contents of the processor status register P onto the stack.\nSince the status register is always an eight-bit register, this is always an eight-bit\noperation, regardless of the settings of the m and x mode select flags on the 65802/\n65816. The status register contents are not changed by the operation. The stack\npointer now points to the next available stack location, directly below the byte\npushed.\nThis provides the means for saving either the current mode settings or a particu\nlar set of status flags so they may be restored or in some other way used later.\nNote, however, that the e bit (the 6502 emulation mode flag on the 65802/65816)\nis not pushed onto the stack or otherwise accessed or saved. The only access to the\ne flag is via the XCE instruction.", "Flags Affected:\n-------------------", "Codes:\nAddressing Mode Syntax\nOpcode\n(hex)\nAvailable to:\n6502 65C02 65802/816\n#0/\nBytes\n#0/\nCycles\nStack (Push) PHP 08 X X  X 1 3" },
    OpcodeDocInfo{ "PHX", "Push Index Register", "Push the contents of the X index register onto the stack. The register itself is\nunchanged.\n8-bit index registers (all processors): The eight-bit contents of the index register\nare pushed onto the stack. The stack pointer now points to the next available stack\nlocation, directly below the byte pushed.\n16-bit index registers (65802/65816 only, x = 0): The sixteen-bit contents of the\nindex register are pushed. The high byte is pushed first, then the low byte. The\nstack pointer now points to the next available stack location, directly below the last\nbyte pushed.", "Flags Affected: -------------------", "Codes:\nOpcode Available to:#0/ n of\nAddressing Mode Syntax (hex) 6502 65C02 65802/816 Bytes Cycles\nStack (Push) PHX DA X  X 1 31\n1 Add 1 cycle if x = 0 (16-bit index registers)" },
    OpcodeDocInfo{ "PHY", "Push Index Register", "Push the contents of the Y index register onto the stack. The register itself is\nunchanged.\n8-bit index registers (all processors): The eight-bit contents of the index register\nare pushed onto the stack. The stack pointer now points to the next available stack\nlocation, directly below the byte pushed.\n16-bit index registers (65802/65816 only, x = 0): The sixteen-bit contents of the\nindex register are pushed. The high byte is pushed first, then the low byte. The\nstack pointer now points to the next available stack location, directly below the last\nbyte pushed.", "Flags Affected: -------------------", "Codes:\nOpcode Available to:# of # of\nAddressing ModeSyntax (hex) 6502 65C02 65802/816 Bytes Cycles\nStack (Push) PHY 5A x x 1 31\n1 Add 1 cycle if x = 0 (16-bit index registers)" },
    OpcodeDocInfo{ "PLA", "Pull Accumulator", "Pull the value on the top of the stack into the accumulator. The previous con\ntents of the accumulator are destroyed.\n8-bit accumulator (all processors): The stack pointer is first incremented. Then\nthe byte pointed to by the stack pointer is loaded into the accumulator.\n16-bit accumulator (65802/65816 only, m = 0): Both accumulator bytes are\npulled. The accumulator's low byte is pulled first, then the high byte is pulled.\nNote that unlike some other microprocessors, the 65x pull instructions set the\nnegative and zero flags.", "Flags Affected: n  z -\nn Set if most significant bit of pulled value is set; else cleared.\nz Set if value pulled is zero; else cleared.", "Codes:\nOpcode Available to:# 0 / # of\nAddressing ModeSyntax (hex) 6502 65C02 65802/816 Bytes Cycles\nStack (Pull) PLA 68 X X  X 1 41\n1 Add 1 cycle if m = 0 (16-bit memory/accumulator)" },
    OpcodeDocInfo{ "PLB", "Pull Data Bank Register", "Pull the eight-bit value on top of the stack into the data bank register B, switch\ning the data bank to that value. All instructions which reference data that specify\nonly sixteen-bit addresses will get their bank address from the value pulled into the\ndata bank register. This is the only instruction that can modify the data bank reg\nister.\nSince the bank register is an eight-bit register, only one byte is pulled from the\nstack, regardless of the settings of the m and x mode select flags. The stack pointer\nis first incremented. Then the byte pointed to by the stack pointer is loaded into the\nregister.", "Flags Affected: n  z -\nn Set if most significant bit of pulled value is set; else cleared,\nz Set if value pulled is zero; else cleared.", "Codes:\nAddressing Mode Syntax\nOpcode\n(hex)\nAvailable to:\n6502 65C02 65802/816\n# 0 /\nBytes\nit of\nCycles\nStack (Pull) PLB AB X 1 4" },
    OpcodeDocInfo{ "PLD", "Pull Direct Page Register", "Pull the sixteen-bit value on top of the stack into the direct page register D,\nswitching the direct page to that value.\nPLD is typically used to restore the direct page register to a previous value.\nSince the direct page register is a sixteen-bit register, two bytes are pulled from\nthe stack, regardless of the settings of the m and x mode select flags. The low byte\nof the direct page register is pulled first, then the high byte. The stack pointer now\npoints to where the high byte just pulled was stored; this is now the next available\nstack location.", "Flags Affected: n  z -\nn Set if most significant bit of pulled value is set; else cleared,\nz Set if value pulled is zero; else cleared.", "Codes:\nAddressing Mode Syntax\nOpcode\n(hex)\nAvailable to:\n6502 65C02 65802/816\n# of\nBytes\n# of\nCycles\nStack (Pull) PLD 2B X 1 5" },
    OpcodeDocInfo{ "PLP", "Pull Status Flags", "Pull the eight-bit value on the top of the stack into the processor status register P,\nswitching the status byte to that value.\nSince the status register is an eight-bit register, only one byte is pulled from the\nstack, regardless of the settings of the m and x mode select flags on the 65802/\n65816. The stack pointer is first incremented. Then the byte pointed to by the stack\npointer is loaded into the status register.\nThis provides the means for restoring either previous mode settings or a particu\nlar set of status flags that reflect the result of a previous operation.\nNote, however, that the e flagthe 6502 emulation mode flag on the 65802/\n65816is not on the stack so cannot be pulled from it. The only means of setting\nthe e flag is the XCE instruction.", "Flags Affected: n v - b d i z c (6502, 65C02,\n65802/65816 emulation mode e = 1)\nn v m x d i z c (65802/65816 native mode e = 0)\nAll flags are replaced by the values in the byte pulled from the stack.", "Codes:\nAddressing Mode Syntax\nOpcode\n(hex)\nAvailable to:\n6502 65C02 65802/816\nHof\nBytes\n# 0 /\nCycles\nStack (Pull) PLP 28 X X  X 1 4" },
    OpcodeDocInfo{ "PLX", "Pull Index Register X from Stack", "Pull the value on the top of the stack into the X index register. The previous con\ntents of the register are destroyed.\n8-bit index registers (all processors): The stack pointer is first incremented. Then\nthe byte pointed to by the stack pointer is loaded into the register.\n16-bit index registers (65802/65816 only, x = 0): Both bytes of the index register\nare pulled. First the low-order byte of the index register is pulled, then the high-\norder byte of the index register is pulled.\nUnlike some other microprocessors, the 65x instructions to pull an index register\naffect the negative and zero flags.", "Flags Affected: n-------------z -\nn Set if most significant bit of pulled value is set; else cleared,\nz Set if value pulled is zero; else cleared.", "Codes:\nAddressing Mode Syntax\nOpcode\n(hex)\nAvailable to:\n6502 65C02 65802/816\nn of\nBytes\n# of\nCycles\nStack (Pull) PLX FA X  X 1 41\n1 Add 1 cycle if x = 0 (16-bit index registers)" },
    OpcodeDocInfo{ "PLY", "Pull Index Register Y from Stack", "Pull the value on the top of the stack into the Y index register. The previous con\ntents of the register are destroyed.\n8-bit index registers (all processors): The stack pointer is first incremented. Then\nthe byte pointed to by the stack pointer is loaded into the register.\n16-bit index registers (65802/65816 only, x = 0): Both bytes of the index register\nare pulled. First the low-order byte of the index register is pulled, then the high-\norder byte of the index register is pulled.\nUnlike some other microprocessors, the 65x instructions to pull an index register\naffect the negative and zero flags.", "Flags Affected: n  z -\nn Set if most significant bit of pulled value is set; else cleared,\nz Set if value pulled is zero; else cleared.", "Codes:\nAddressing Mode Syntax\nOpcode\n(hex)\nAvailable to:\n6502 65C02 65802/816\n#o/\nBytes\nn of\nCycles\nStack (Pull) PLY 7A x x 1 41\n1 Add 1 cycle if x = 0 (16-bit index registers)" },
    OpcodeDocInfo{ "REP", "Reset Status Bits", "For each bit set to one in the operand byte, reset the corresponding bit in the\nstatus register to zero. For example, if bit three is set in the operand byte, bit three\nin the status register (the decimal flag) is reset to zero by this instruction. Zeroes in\nthe operand byte cause no change to their corresponding status register bits.\nThis instruction lets you reset any flag or flags in the status register with a single\ntwo-byte instruction. Further, it is the only direct means of resetting several of the\nflags, including the m and x mode select flags (although instructions that pull the P\nstatus register affect the m and x mode select flags).\n6502 emulation mode (65802/65816, e = l): Neither the break flag nor bit five\n(the 6502's undefined flag bit) are affected by REP.", "Flags Affected: n v - - d i z c (65802/65816 emulation mode e = 1)\nn v m x d i z c (65802/65816 native mode e = 0)\nAll flags for which an operand bit is set are reset to zero.\nAll other flags are unaffected by the instruction.", "Codes:\nAddressing Mode Syntax\nOpcode\n(hex)\nAvailable to:\n6502 65C02 65802/816\n# 0 /\nBytes\n# 0 /\nCycles\nImmediate REP ttconstC2 X 2 3" },
    OpcodeDocInfo{ "ROL", "Rotate Memory or Accumulator Left", "Rotate the contents of the location specified by the operand left one bit. Bit one\ntakes on the value originally found in bit zero, bit two takes the value originally in\nbit one, and so on; the rightmost bit, bit zero, takes the value in the carry flag; the\nleftmost bit (bit 7 on the 6502 and 65C02 or if m = 1 on the 65802/65816, or bit 15\nif m = 0) is transferred into the carry flag.\n* rYYYYYY\\\n1 0 1 1 0 0\nCarry Flag\nFigure 18.8. ROL.\n8-bit accumulator/memory (all processors): Data rotated is eight bits, plus carry.\n16-bit accumulator/memory (65802/65816 only, m = 0): Data rotated is sixteen\nbits, plus carry: if in memory, the low-order eight bits are located at the effective\naddress; the high eight bits are located at the effective address plus one.", "Flags Affected: n--------------zc\nn Set if most significant bit of result is set; else cleared,\nz Set if result is zero; else cleared.\nc High bit becomes carry: set if high bit was set; cleared if high bit was\nclear.", "Codes:\nAddressing Mode Syntax\nOpcode\n(hex) 6502\nAvailable to:\n65C02 65802/816\nn of\nBytes\nHof\nCycles\nAccumulator ROL A 2A X X X 1 2\nAbsolute ROL addr 2E X X X 3 61\nDirect Page (also DP) ROL dp 26 X X X 2 5U\nAbsolute Indexed,X ROL addr,X 3E X X X 3 yl,3\nDP Indexed,X ROL dp,X 36 X X X 2 61,2\n1 Add 2 cycles if m = 0 (16-bit memory/accumulator)\n2 Add 1 cycle if low byte of Direct Page register is other than zero (DL< >0)\n3 Subtract 1 cycle if 65C02 and no page boundary crossed" },
    OpcodeDocInfo{ "ROR", "Rotate Memory or Accumulator Right", "Rotate the contents of the location specified by the operand right one bit. Bit\nzero takes on the value originally found in bit one, bit one takes the value origi\nnally in bit two, and so on; the leftmost bit (bit 7 on the 6502 and 65C02 or if m =\n1 on the 65802/65816, or bit 15 if m = 0) takes the value in the carry flag; the\nrightmost bit, bit zero, is transferred into the carry flag.\n1 0 1 1 0 0 1 1\nFigure 18.9. ROR.\n8-bit accumulator/memory (all processors): Data rotated is eight bits, plus carry.\n16-bit accumulator/memory (65802/65816 only, m = 0): Data rotated is sixteen\nbits, plus carry: if in memory, the low-order eight bits are located at the effective\naddress; the high-order eight bits are located at the effective address plus one.", "Flags Affected: n--------------zc\nn Set if most significant bit of result is set; else cleared,\nz Set if result is zero; else cleared.\nc Low bit becomes carry: set if low bit was set; cleared if low bit was\nclear.", "Codes:\nAddressing Mode Syntax\nOpcode\n(hex) 6502\nAvailable to:\n65C02 65802/816\nn of\nBytes\nHof\nCycles\nAccumulator ROR A 6A X X X 1 2\nAbsolute ROR addr 6E X X X 3 61\nDirect Page (also DP) ROR dp 66 X X X 2 512\nAbsolute Indexed,X ROR addr.X7E X X X 3 71.3\nDP Indexed,X ROR dp,X 76 X X X 2 61 2\n1 Add 2 cycles if m = 0 (16-bit memory/accumulator)\n2 Add 1 cycle if low byte of Direct Page register is other than zero (DL< >0)\n3 Subtract 1 cycle if 65C02 and no page boundary crossed" },
    OpcodeDocInfo{ "RTI", "and before loading it into the program counter;  on the other hand", nullptr, nullptr, nullptr },
    OpcodeDocInfo{ "RTL", "Stack  Addressing", nullptr, nullptr, nullptr },
    OpcodeDocInfo{ "RTS", "Return from Subroutine", "Pull the program counter, incrementing the stacked, sixteen-bit value by one\nbefore loading the program counter with it.\nWhen a subroutine is called (via a jump to subroutine instruction), the current\nreturn address is pushed onto the stack. To return to the code following the sub\nroutine call, a return instruction must be executed, which pulls the return address\nfrom the stack, increments it, and loads the program counter with it, transferring\ncontrol to the instruction immediately following the jump to subroutine.\nStack\n(Stack Pointer After)\nReturn Address High\nReturn Address Low\nStack Pointer Before\nBank 0\nFigure 18.12. Stack before RTS.", "Flags Affected:\n-------------------", "Codes:\nOpcode Available to: # of # of\nAddressing Mode Syntax (hex) 6502 65C02 65802/816 Bytes Cycles\nStack (RTS) RTS 60 x x x 1 6" },
    OpcodeDocInfo{ "SBC", "Subtract with Borrow from Accumulator", "Subtract the data located at the effective address specified by the operand from\nthe contents of the accumulator; subtract one more if the carry flag is clear, and\nstore the result in the accumulator.\nThe 65x processors have no subtract instruction that does not involve the carry.\nTo avoid subtracting the carry flag from the result, either you must be sure it is set\nor you must explicitly set it (using SEC) prior to executing the SBC instruction.\nIn a multi-precision (multi-word) subtract, you set the carry before the low\nwords are subtracted. The low word subtraction generates a new carry flag value\nbased on the subtraction. The carry is set if no borrow was required and cleared if\nborrow was required. The complement of the new carry flag (one if the carry is\nclear) is subtracted during the next subtraction, and so on. Each result thus cor\nrectly reflects the borrow from the previous subtraction.\nNote that this use of the carry flag is the opposite of the way the borrow flag is\nused by some other processors, which clear (not set) the carry if no borrow was\nrequired.\nd flag clear: Binary subtraction is performed.\nd flag set: Binary coded decimal (BCD) subtraction is performed.\n8-bit accumulator (all processors): Data subtracted from memory is eight-bit.\n16-bit accumulator (65802/65816 only, m = 0): Data subtracted from memory is\nsixteen-bit: the low eight bits is located at the effective address; the high eight bits is\nlocated at the effective address plus one.", "Flags Affected: n v", nullptr },
    OpcodeDocInfo{ "SEC", "Set Carry Flag", "Set the carry flag in the status register.\nSEC is used prior to subtraction (using the 65x's SBC instruction) to keep the\ncarry flag from affecting the result, and prior to an XCE (exchange carry flag with\nemulation bit) instruction to put the 65802 or 65816 into 6502 emulation mode.", "Flags Affected:  c\nc Carry flag set always.", "Codes:\nAddressing Mode Syntax\nOpcode\n(hex)\nAvailable to:\n6502 65C02 65802/816\n# 0/  # of\nBytes Cycles\nImplied SEC 3 8 X X  X 1 2" },
    OpcodeDocInfo{ "SED", "Set Decimal Mode Flag", "Set the decimal mode flag in the status register.\nSED is used to shift 65x processors into decimal mode from binary mode, so that\nthe ADC and SBC instructions will operate correctly on BCD data, performing\nautomatic decimal adjustment.", "Flags Affected:---------d-------\nd Decimal mode flag set always.", "Codes:\nOpcode Available to:# 0 /  # of\nAddressing Mode Syntax (hex) 6502 65C02 65802/816 Bytes Cycles\nImplied SED F8 X X  X 1  2" },
    OpcodeDocInfo{ "SEI", "Set Interrupt Disable Flag", "Set the interrupt disable flag in the status register.\nSEI is used to disable hardware interrupt processing. When the i bit is set, mask\nable hardware interrupts (IRQ') are ignored. The processor itself sets the i flag\nwhen it begins servicing an interrupt, so interrupt handling routines that are\nintended to be interruptable must reenable interrupts with CLI. If interrupts are to\nremain blocked during the interrupt service, exiting the routine via RTI will auto\nmatically restore the status register with the i flag clear, re-enabling interrupts.", "Flags Affected: -----------i \ni Interrupt disable flag set always.", "Codes:\nOpcode Available to:# of # of\nAddressing Mode Syntax (hex) 6502 65C02 65802/816 Bytes Cycles\nImplied SEI 78 X X  X 1  2" },
    OpcodeDocInfo{ "SEP", "Set Status Bits", "For each one-bit in the operand byte, set the corresponding bit in the status regis\nter to one. For example, if bit three is set in the operand byte, bit three in the status\nregister (the decimal flag) is set to one by this instruction. Zeroes in the operand\nbyte cause no change to their corresponding status register bits.\nThis instruction lets you set any flag or flags in the status register with a single\ntwo-byte instruction. Furthermore, it is the only direct means of setting the m and x\nmode select flags. (Instructions that pull the P status register indirectly affect the m\nand x mode select flags).\n6502 emulation mode (65802/65816, e = l): Neither the break flag nor bit five\n(the 6502's non-flag bit) is affected by SEP.", "Flags Affected: n v - - d i z c (65802/65816 emulation e = 1)\nn v m x d i z c (65802/65816 native mode e = 0)\nAll flags for which an operand bit is set are set to one.\nAll other flags are unaffected by the instruction.", "Codes:\nAddressing Mode Syntax\nOpcode\n(hex)\nAvailable to:\n6502 65C02 65802/816\n# of # of\nBytes Cycles\nImmediate SEP ttconstE2 X 2 3" },
    OpcodeDocInfo{ "STA", "Store Accumulator to Memory", "Store the value in the accumulator to the effective address specified by the oper\nand.\n8-bit accumulator (all processors): Value is eight-bit.\n16-bit accumulator (65802/65816 only, m = 0): Value is sixteen-bit: the low-order\neight bits are stored to the effective address; the high-order eight bits are stored to\nthe effective address plus one.\nThe 65x flags are unaffected by store instructions.", "Flags Affected: -------------------", "Codes:\nAddressing Mode+ + Syntax\nOpcode\n(hex) 6502\nAvailable on:\n65C02 65802/816\n# of Hof\nBytes Cycles\nAbsolute STA addr 8D X X X 3 4 1\nAbsolute Long STA long 8F X 4 5 1\nDirect Page (also DP) STA dp 85 X X X 2 31 2\nDP Indirect STA (dp) 92 X X 2 51,2\nDP Indirect Long STA [dpi 87 X 2 612\nAbsolute Indexed, X STA addr,X 9D X X X 3 5 1\nAbsolute Long Indexed,X STA long.X 9F X 4 51\nAbsolute Indexed, Y STA addr,Y 99 X X X 3 51\nDP Indexed,X STA dp,X 95 X X X 2 4u\nDP Indexed Indirect,X STA (dp,X) 81 X X X 2 612\nDP Indirect Indexed, Y STA (dp),Y 91 X X X 2 612\nDP Indirect Long Indexed,Y STA [dp],Y 97 X 2 61  2\nStack Relative (also SR) STA sr,S 83 X 2 41\nSR Indirect Indexed, Y STA (sr,S),Y 93 X 2 71\n+ +STA, a Primary Group Instruction, has available all of the Primary Group addressing modes and bit patterns\n1 Add 1 cycle if m = 0 (16-bit memory/accumulator)\n2 Add 1 cycle if low byte of Direct Page register is other than zero (DL < > 0)" },
    OpcodeDocInfo{ "STP", "Stop the Processor", "During the processor's next phase 2 clock cycle, stop the processor's oscillator\ninput; the processor is effectively shut down until a reset occurs (until the RES' pin\nis pulled low).\nSTP is designed to put the processor to sleep while it's not (actively) in use in\norder to reduce power consumption. Since power consumption is a function of fre\nquency with CMOS circuits, stopping the clock cuts power to almost nil.\nYour reset handling routine (pointed to by the reset vector, $00:FFFC-FD) should\nbe designed to either reinitialize the system or resume control through a\npreviously-installed reset handler.\nRemember that reset is an interrupt-like signal that causes the emulation bit to be\nset to one. It also causes the direct page register to be reset to zero; stack high to be\nset to one (forcing the stack pointer to page one); and the mode select flags to be set\nto one (eight-bit registers; a side effect is that the high bytes of the index registers\nare zeroed). STP is useful only in hardware systems (such as battery-powered sys\ntems) specifically designed to support a low-power mode.\nFlags Affected;\n-------------------", nullptr, "Codes:\nAddressing Mode Syntax\nOpcode\n(hex)\nAvailable on:\n6502 65C02 65802/816\n# 0 /  # 0 /\nBytes Cycles\nImplied STP DB X 1 31\n1 Uses 3 cycles to shut the processor down; additional cycles are required by reset to restart it" },
    OpcodeDocInfo{ "STX", "Store Index Register X to Memory", "Store the value in index register X to the effective address specified by the oper\nand.\n8-bit index registers (all processors): Value is eight-bit.\n16-bit index registers (65802/65816 only, x = 0): Value is sixteen-bit: the low-\norder eight bits are stored to the effective address; the high-order eight bits are\nstored to the effective address plus one.\nThe 65x flags are unaffected by store instructions.", "Flags Affected: -------------------", "Codes:\nAddressing Mode Syntax\nOpcode\n(hex)\nAvailable on:\n6502 65C02 65802/816\n* of # of\nBytes Cycles\nAbsolute SIX addr 8E X X  X 3 41\nDirect Page STX dp 86 X X  X 2 3 1 * 2\nDirect Page Indexed, Y STX dp,Y 96 X X  X 2 41.2\n1 Add 1 cycle if x = 0 (16-bit index registers)\n2 Add 1 cycle if low byte of Direct Page register is other than zero (DL< >0)" },
    OpcodeDocInfo{ "STY", "Store Index Register Y to Memory", "Store the value in index register Y to the effective address specified by the oper\nand.\n8-bit index registers (all processors): Value is eight-bit.\n16-bit index registers (65802/65816 only, x = 0): Value is sixteen-bit: the low-\norder eight bits are stored to the effective address; the high-order eight bits are\nstored to the effective address plus one.\nThe 65x flags are unaffected by store instructions.", "Flags Affected:\n-------------------", "Codes:\nAddressing Mode Syntax\nOpcode\n(hex)\nAvailable on:\n6502 65C02 65802/816\n# 0 /  # of\nBytes Cycles\nAbsolute STY addr 8C X X  X 3 41\nDirect Page STY dp 84 X X  X 2 31 , 2\nDirect Page Indexed, X STY dp,X 94 X X  X 2 4 1 . 2\n1 Add 1 cycle if x = 0 (16-bit index registers)\n2 Add 1 cycle if low byte of Direct Page register is other than zero (DL< >0)" },
    OpcodeDocInfo{ "STZ", "Store Zero to Memory", "Store zero to the effective address specified by the operand.\n8-bit accumulator (all processors): Zero is stored at the effective address.\n16-bit accumulator/memory (65802/65816 only, m = 0): Zero is stored at the\neffective address and at the effective address plus one.\nThe 65x store zero instruction does not affect the flags.", "Flags Affected: -------------------", "Codes:\nAddressing Mode Syntax\nOpcode\n(hex)\nAvailable on:\n6502 65C02 65802/816\n# of * of\nBytes Cycles\nAbsolute STZ addr 9C X  X 3 41\nDirect Page STZ dp 64 X  X 2 312\nAbsolute Indexed,X STZ addr,X 9E X  X 3 5 1\nDirect Page Indexed,X STZ dp,X 74 X  X 2 4*2\n1 Add 1 cycle if m = 0 (16-bit memory/accumulator)\n2 Add 1 cycle if low byte of Direct Page register is other than zero (DL< >0)" },
    OpcodeDocInfo{ "TAX", "Transfer Accumulator to Index Register X", "Transfer the value in the accumulator to index register X. If the registers are dif\nferent sizes, the nature of the transfer is determined by the destination register. The\nvalue in the accumulator is not changed by the operation.\n8-bit accumulator, 8-bit index registers (all processors): Value transferred is\neight-bit.\n8-bit accumulator, 16-bit index registers (65802/65816 only, m = 1, x = 0): Value\ntransferred is sixteen-bit; the eight-bit A accumulator becomes the low byte of the\nindex register; the hidden eight-bit B accumulator becomes the high byte of the\nindex register.\n16-bit accumulator, 8-bit index registers (65802/65816 only, m = 0, x = l): Value\ntransferred to the eight-bit index register is eight-bit, the low byte of the accumu\nlator.\n16-bit accumulator, 16-bit index registers (65802/65816 only, m = 0, x = 0):\nValue transferred to the sixteen-bit index register is sixteen-bit, the full sixteen-bit\naccumulator.", "Flags Affected: n------------z -\nn Set if most significant bit of transferred value is set; else cleared,\nz Set if value transferred is zero; else cleared.", "Codes:\nAddressing Mode Syntax\nOpcode\n(hex)\nAvailable to:\n6502 65C02 65802/816\ntt of it of\nBytes Cycles\nImplied TAX AA XX X 1 2" },
    OpcodeDocInfo{ "TAY", "Transfer Accumulator to Index Register Y", "Transfer the value in the accumulator to index register Y. If the registers are dif\nferent sizes, the nature of the transfer is determined by the destination register. The\nvalue in the accumulator is not changed by the operation.\n8-bit accumulator, 8-bit index registers (all processors): Value transferred is\neight-bit.\n8-bit accumulator, 16-bit index registers (65802/65816 only, m = 1, x = 0): Value\ntransferred is sixteen-bit; the eight-bit A accumulator becomes the low byte of the\nindex register; the hidden eight-bit B accumulator becomes the high byte of the\nindex register.\n16-bit accumulator, 8-bit index registers (65802/65816 only, m = 0, x = 1): Value\ntransferred to the eight-bit index register is eight-bit, the low byte of the accumu\nlator.\n16-bit accumulator, 16-bit index registers (65802/65816 only, m = 0, x = 0):\nValue transferred to the sixteen-bit index register is sixteen-bit, the full sixteen-bit\naccumulator.", "Flags Affected: n  z -\nn Set if most significant bit of transferred value is set; else cleared,\nz Set if value transferred is zero; else cleared.", "Codes:\nAddressing Mode Syntax\nOpcode\n(hex)\nAvailable to:\n6502 65C02 65802/816\n# 0 /  # 0 /\nBytes Cycles\nImplied TAY A 8 X X  X 1 2" },
    OpcodeDocInfo{ "TCD", "Transfer 16-Bit Accumulator to Direct Page Register", "Transfer the value in the sixteen-bit accumulator C to the direct page register D,\nregardless of the setting of the accumulator/memory mode flag.\nAn alternate mnemonic is TAD, (transfer the value in the A accumulator to the\ndirect page register).\nIn TCD, the \"C\" is used to indicate that sixteen bits are transferred regardless of\nthe m flag. If the A accumulator is set to just eight bits (whether because the m flag\nis set, or because the processor is in 6502 emulation mode), then its value becomes\nthe low byte of the direct page register and the value in the hidden B accumulator\nbecomes the high byte of the direct page register.\nThe accumulator's sixteen-bit value is unchanged by the operation.", "Flags Affected: n z -\nn Set if most significant bit of transferred value is set; else cleared,\nz Set if value transferred is zero; else cleared.", "Codes:\nOpcode Available to: n of # 0/\nAddressing Mode Syntax (hex) 6502 65C02 65802/816 Bytes Cycles\nImplied TCD\n(or TAD)\n5B X 1 2" },
    OpcodeDocInfo{ "TCS", "Transfer Accumulator to Stack Pointer", "Transfer the value in the accumulator to the stack pointer S. The accumulator's\nvalue is unchanged by the operation.\nAn alternate mnemonic is TAS (transfer the value in the A accumulator to the\nstack pointer).\nIn TCS, the \"C\" is used to indicate that, in native mode, sixteen bits are trans\nferred regardless of the m flag. If the A accumulator is set to just eight bits (because\nthe m flag is set), then its value is transferred to the low byte of the stack pointer\nand the value in the hidden B accumulator is transferred to the high byte of the\nstack pointer. In emulation mode, only the eight-bit A accumulator is transferred,\nsince the high stack pointer byte is forced to one (the stack is confined to page one).\nTCS, along with TXS, are the only two instructions for changing the value in the\nstack pointer. The two are also the only two transfer instructions not to alter the\nflags.", "Flags Affected:\n-------------------", "Codes:\nAddressing Mode Syntax\nOpcode\n(hex)\nAvailable to:\n6502 65C02 65802/816\n# of # 0/\nBytes Cycles\nImplied TCS\n(or TAS)\nIB X 1 2" },
    OpcodeDocInfo{ "TDC", "Transfer Direct Page Register to 16-Bit Accumulator", "Transfer the value in the sixteen-bit direct page register D to the sixteen-bit accu\nmulator C, regardless of the setting of the accumulator/memory mode flag.\nAn alternate mnemonic is TDA (transfer the value in the direct page register to\nthe A accumulator).\nIn TDC, the \"C\" is used to indicate that sixteen bits are transferred regardless of\nthe m flag. If the A accumulator is set to just eight bits (whether because the m flag\nis set, or because the processor is in 6502 emulation mode), then it takes the value\nof the low byte of the direct page register and the hidden B accumulator takes the\nvalue of the high byte of the direct page register.\nThe direct page register's sixteen-bit value is unchanged by the operation.", "Flags Affected: n--------------z -\nn Set if most significant bit of transferred value is set; else cleared,\nz Set if value transferred is zero; else cleared.", "Codes:\nOpcode Available to: it of tt of\nAddressing Mode Syntax (hex) 6502 65C02 65802/816 Bytes Cycles\nI m p l i e d TDC 7B\n(or TDA)\nx  1 2" },
    OpcodeDocInfo{ "TRB", "Test and Reset Memory Bits Against Accumulator", "Logically AND together the complement of the value in the accumulator with the\ndata at the effective address specified by the operand. Store the result at the mem\nory location.\nThis has the effect of clearing each memory bit for which the corresponding\naccumulator bit is set, while leaving unchanged all memory bits in which the cor\nresponding accumulator bits are zeroes.\nUnlike the BIT instruction, TRB is a read-modify-write instruction, not only cal\nculating a result and modifying a flag, but also storing the result to memory as\nwell.\nThe z zero flag is set based on a second and different operation, the ANDing of\nthe accumulator value (not its complement) with the memory value (the same way\nthe BIT instruction affects the zero flag). The result of this second operation is not\nsaved; only the zero flag is affected by it.\n8-bit accumulator/memory (65C02; 65802/65816, m = 1): Values in accumulator\nand memory are eight-bit.\n16-bit accumulator/memory (65802/65816 only, m = 0): Values in accumulator\nand memory are sixteen-bit: the low-order eight bits are located at the effective\naddress; the high-order eight bits are at the effective address plus one.", "Flags Affected:  z -\nz Set if memory value AND'ed with accumulator value is zero; else\ncleared.", "Codes:\nAddressing Mode Syntax\nOpcode\n(hex)\nAvailable on:\n6502 65C02 65802/816\n# 0/  # of\nBytes Cycles\nAbsolute TRB addr 1C X  X 3 61\nDirect Page TRB dp 1 4 X  X 2 5 U\n1 Add 2 cycles if m = 0 (16-bit memory/accumulator)\n2 Add 1 cycle if low byte of Direct Page register is other than zero (DL< >0)" },
    OpcodeDocInfo{ "TSB", "Test and Set Memory Bits Against Accumulator", "Logically OR together the value in the accumulator with the data at the effective\naddress specified by the operand. Store the result at the memory location.\nThis has the effect of setting each memory bit for which the corresponding accu\nmulator bit is set, while leaving unchanged all memory bits in which the corres\nponding accumulator bits are zeroes.\nUnlike the BIT instruction, TSB is a read-modify-write instruction, not only cal\nculating a result and modifying a flag, but storing the result to memory as well.\nThe z zero flag is set based on a second different operation, the ANDing of the\naccumulator value with the memory value (the same way the BIT instruction\naffects the zero flag). The result of this second operation is not saved; only the zero\nflag is affected by it.\n8-bit accumulator/memory (65C02; 65802/65816, m = 1): Values in accumula\ntor and memory are eight-bit.\n16-bit accumulator/memory (65802/65816 only, m = 0); Values in accumulator\nand memory are sixteen-bit: the low-order eight bits are located at the effective\naddress; the high-order eight bits are at the effective address plus one.", "Flags Affected:  z -\nz Set if memory value AND'ed with accumulator value is zero; else\ncleared.", "Codes:\nAddressing Mode Syntax\nOpcode\n(hex)\nAvailable on:\n6502 65C02 65802/816\n# of it of\nBytes Cycles\nAbsolute TSB addr OC X  X 3 61\nDirect Page TSB dp 04 X  X 2 51,2\n1 Add 2 cycles if m = 0 (16-bit memory/accumulator)\n2 Add 1 cycle if low byte of Direct Page register is other than zero (DL< >0)" },
    OpcodeDocInfo{ "TSC", "Transfer Stack Pointer to 16-Bit Accumulator", "Transfer the value in the sixteen-bit stack pointer S to the sixteen-bit accumulator\nC, regardless of the setting of the accumulator/memory mode flag.\nAn alternate mnemonic is TSA (transfer the value in the stack pointer to the A\naccumulator).\nIn TSC, the \"C\" is used to indicate that sixteen bits are transferred regardless of\nthe m flag. If the A accumulator is set to just eight bits (whether because the m flag\nis set, or because the processor is in 6502 emulation mode), then it takes the value\nof the low byte of the stack pointer and the hidden B accumulator takes the value\nof the high byte of the stack pointer. (In emulation mode, B will always take a\nvalue of one, since the stack is confined to page one.)\nThe stack pointer's value is unchanged by the operation.", "Flags Affected: n--------------z -\nn Set if most significant bit of transferred value is set; else cleared,\nz Set if value transferred is zero; else cleared.", "Codes:\nOpcode Available to: n of#0/\nAddressing Mode Syntax (hex) 6502 65C02 65802/816 Bytes Cycles\nImplied TSC\n(or TSA)\n3B x 1 2" },
    OpcodeDocInfo{ "TSX", "Transfer Stack Pointer to Index Register X", "Transfer the value in the stack pointer S to index register X. The stack pointer's\nvalue is not changed by the operation.\n8-bit index registers (all processors): Only the low byte of the value in the stack\npointer is transferred to the X register. In the 6502, the 65C02, and the 6502 emula\ntion mode, the stack pointer and the index registers are only a single byte each, so\nthe byte in the stack pointer is transferred to the eight-bit X register. In 65802/\n65816 native mode, the stack pointer is sixteen bits, so its most significant byte is\nnot transferred if the index registers are in eight-bit mode.\n16-bit index registers (65802/65816 only, x = 0): The full sixteen-bit value in the\nstack pointer is transferred to the X register.", "Flags Affected: n----------z -\nn Set if most significant bit of transferred value is set; else cleared,\nz Set if value transferred is zero; else cleared.", "Codes:\nAddressing Mode Syntax\nOpcode\n(hex)\nAvailable to:\n6502 65C02 65802/816\nn of Hof\nBytes Cycles\nImplied TSX BA X X  X 1 2" },
    OpcodeDocInfo{ "TXA", "Transfer Index Register X to Accumulator", "Transfer the value in index register X to the accumulator. If the registers are dif\nferent sizes, the nature of the transfer is determined by the destination (the accumu\nlator). The value in the index register is not changed by the operation.\n8-bit index registers, 8-bit accumulator (all processors): Value transferred is\neight-bit.\n16-bit index registers, 8-bit accumulator (65802/65816 only, x = 0, m = 1): Value\ntransferred to the eight-bit accumulator is eight-bit, the low byte of the index regis\nter; the hidden eight-bit accumulator B is not affected by the transfer.\n8-bit index registers, 16-bit accumulator (65802/65816 only, x = 1, m = 0): The\neight-bit index register becomes the low byte of the accumulator; the high accumu\nlator byte is zeroed.\n16-bit index registers, 16-bit accumulator (65802/65816 only, x = 0, m = 0):Value\ntransferred to the sixteen-bit accumulator is sixteen-bit, the full sixteen-bit index\nregister.", "Flags Affected: n--------------z -\nn Set if most significant bit of transferred value is set; else cleared,\nz Set if value transferred is zero; else cleared.", "Codes:\nAddressing Mode Syntax\nOpcode\n(hex)\nAvailable to:\n6502 65C02 65802/816\nn of Hof\nBytes Cycles\nImplied TXA 8A X X  X 1 2" },
    OpcodeDocInfo{ "TXS", "Transfer Index Register X to Stack Pointer", "Transfer the value in index register X to the stack pointer, S. The index register's\nvalue is not changed by the operation.\nTXS, along with TCS, are the only two instructions for changing the value in the\nstack pointer. The two are also the only two transfer instructions that do not alter\nthe flags.\n6502, 65C02, and 6502 emulation mode(65802/65816, e = 1): The stack pointer is\nonly eight bits (it is concatenated to a high byte of one, confining the stack to page\none), and the index registers are only eight bits. The byte in X is transferred to the\neight-bit stack pointer.\n8-bit index registers (65802/65816 native mode, x = l): The stack pointer is six\nteen bits but the index registers are only eight bits. A copy of the byte in X is trans\nferred to the low stack pointer byte and the high stack pointer byte is zeroed.\n16-bit index registers (65802/65816 native mode, x = 0): The full sixteen-bit value\nin X is transferred to the sixteen-bit stack pointer.", "Flags Affected: -------------------", "Codes:\nAddressing Mode Syntax\nOpcode\n(hex)\nAvailable to:\n6502 65C02 65802/816\n# of # of\nBytes Cycles\nImplied TXS 9A X X  X 1 2" },
    OpcodeDocInfo{ "TXY", "Transfer Index Registers X to Y", "Transfer the value in index register X to index register Y. The value in index reg\nister X is not changed by the operation. Note that the two registers are never differ\nent sizes.\n8-bit index registers (x = 1): Value transferred is eight-bit.\n16-bit index registers (x = 0): Value transferred is sixteen-bit.", "Flags Affected: n--------------z -\nn Set if most significant bit of transferred value is set; else cleared,\nz Set if value transferred is zero; else cleared.", "Codes:\nOpcode Available to: It of # of\nAddressing Mode Syntax (hex) 6502 65C02 65802/816 Bytes Cycles\nImplied TXY 9B x 1 2" },
    OpcodeDocInfo{ "TYA", "Transfer Index Register Y to Accumulator", "Transfer the value in index register Y to the accumulator. If the registers are dif\nferent sizes, the nature of the transfer is determined by the destination (the accumu\nlator). The value in the index register is not changed by the operation.\n8-bit index registers, 8-bit accumulator (all processors): Value transferred is\neight-bit.\n16-bit index registers, 8-bit accumulator (65802/65816 only, x = 0, m = 1): Value\ntransferred to the eight-bit accumulator is eight-bit, the low byte of the index regis\nter; the hidden eight-bit accumulator B is not affected by the transfer.\n8-bit index registers, 16-bit accumulator (65802/65816 only, x = 1, m = 0): The\neight-bit index register becomes the low byte of the accumulator; the high accumu\nlator byte is zeroed.\n16-bit index registers, 16-bit accumulator (65802/65816 only, x = 0, m = 0):\nValue transferred to the sixteen-bit accumulator is sixteen-bit, the full sixteen-bit\nindex register.", "Flags Affected: n--------------z -\nn Set if most significant bit of transferred value is set; else cleared,\nz Set if value transferred is zero; else cleared.", "Codes:\nAddressing Mode Syntax\nOpcode\n(hex)\nAvailable to:\n6502 65C02 65802/816\nHof %  of\nBytes Cycles\nImplied TYA 98 XX X 1 2" },
    OpcodeDocInfo{ "TYX", "Transfer Index Registers Y to X", "Transfer the value in index register Y to index register X. The value in index reg\nister Y is not changed by the operation. Note that the two registers are never differ\nent sizes.\n8-bit index registers (x = 1): Value transferred is eight-bit.\n16-bit index registers (x = 0): Value transferred is sixteen-bit.", "Flags Affected: n--------------z -\nn Set if most significant bit of transferred value is set; else cleared,\nz Set if value transferred is zero; else cleared.", "Codes:\nOpcode Available to: # of # of\nAddressing Mode Syntax (hex) 6502 65C02 65802/816 Bytes Cycles\nImplied TYX BB x 1 2" },
    OpcodeDocInfo{ "WAI", "Wait for Interrupt", "Pull the RDY pin low. Power consumption is reduced and RDY remains low\nuntil an external hardware interrupt (NMI, IRQ, ABORT, or RESET) is received.\nWAI is designed to put the processor to sleep during an external event to reduce\nits power consumption, to allow it to be synchronized with an external event, and/\nor to reduce interrupt latency (an interrupt occurring during execution of an\ninstruction is not acted upon until execution of the instruction is complete, perhaps\nmany cycles later; WAI ensures that an interrupt is recognized immediately).\nOnce an interrupt is received, control is vectored through one of the hardware\ninterrupt vectors; an RTI from the interrupt handling routine will return control to\nthe instruction following the original WAI. However, if by setting the i flag, inter\nrupts have been disabled prior to the execution of the WAI instruction, and IRQ' is\nasserted, the \"wait\" condition is terminated and control resumes with the next\ninstruction, rather than through the interrupt vectors. This provides the quickest\nresponse to an interrupt, allowing synchronization with external events. WAI also\nfrees up the bus; since RDY is pulled low in the third instruction cycle, the proces\nsor may be disconnected from the bus if BE is also pulled low.", "Flags Affected:\n-------------------", "Codes:\nAddressing Mode Syntax\nOpcode\n(hex)\nAvailable to:\n6502 65C02 65802/816\n# 0/  # 0/\nBytes Cycles\nImplied WAI CB X 1 31\nlUses 3 cycles to shut the processor down; additional cycles are required by interrupt to restart it" },
    OpcodeDocInfo{ "WDM", "Reserved for Future Expansion", nullptr, nullptr, nullptr },
    OpcodeDocInfo{ "XBA", "Exchange the B and A Accumulators", "B represents the high-order byte of the sixteen-bit C accumulator, and A in this\ncase represents the low-order byte. XBA swaps the contents of the low-order and\nhigh-order bytes of C.\nAn alternate mnemonic is SWA (swap the high and low bytes of the sixteen-bit A\naccumulator).\nXBA can be used to invert the low-order, high-order arrangement of a sixteen-bit\nvalue, or to temporarily store an eight-bit value from the A accumulator into B.\nSince it is an exchange, the previous contents of both accumulators are changed,\nreplaced by the previous contents of the other.\nNeither the mode select flags nor the emulation mode flag affects this operation.\nThe flags are changed based on the new value of the low byte, the A accumulator\n(that is, on the former value of the high byte, the B accumulator), even in sixteen-\nbit accumulator mode.", "Flags Affected: n -------------z -\nn Set if most significant bit of new 8-bit value in A accumulator is set;\nelse cleared.\nz Set if new 8-bit value in A accumulator is zero; else cleared.", "Codes:\nAddressing Mode Syntax\nOpcode\n(hex)\nAvailable to:\n6502 65C02 65802/816\n# of n of\nBytes Cycles\nImplied XBA\n(or SWA)\nEB X 1 3" },
    OpcodeDocInfo{ "XCE", "Exchange Carry and Emulation Bits", "This instruction is the only means provided by the 65802 and 65816 to shift\nbetween 6502 emulation mode and the full, sixteen-bit native mode.\nThe emulation mode is used to provide hardware and software compatibility\nbetween the 6502 and 65802/65816.\nIf the processor is in emulation mode, then to switch to native mode, first clear\nthe carry bit, then execute an XCE. Since it is an exchange operation, the carry flag\nwill reflect the previous state of the emulation bit. Switching to native mode causes\nbit five to stop functioning as the break flag, and function instead as the x mode\nselect flag. A second mode select flag, m, uses bit six, which was unused in emula\ntion mode. Both mode select flags are initially set to one (eight-bit modes). There\nare also other differences described in the text.\nIf the processor is in native mode, then to switch to emulation mode, you first set\nthe carry bit, then execute an XCE. Switching to emulation mode causes the mode\nselect flags (m and x) to be lost from the status register, with x replaced by the b\nbreak flag. This forces the accumulator to eight bits, but the high accumulator byte\nis preserved in the hidden B accumulator. It also forces the index registers to eight\nbits, causing the loss of values in their high bytes, and the stack to page one, caus\ning the loss of the high byte of the previous stack address. There are also other dif\nferences described in the text.\ne", "Flags Affected:   mb/x c\ne Takes carry's previous value: set if carry was set; else cleared,\nc Takes emulation's previous value: set if previous mode was\nemulation; else cleared,\nm m is a native mode flag only; switching to native mode sets it to 1.\nx x is a native mode flag only; it becomes the b flag in emulation,\nb b is an emulation mode flag only; it is set to 1 to become the x flag in\nnative.", "Codes:\nAddressing Mode Syntax\nOpcode\n(hex)\nAvailable to:\n6502 65C02 65802/816\nHof Hof\nBytes Cycles\nImplied XCE FB X 1 2" },
};

struct HardwareQuirk {
    const char* type;
    const char* text;
    const char* source;
};

constexpr std::array<HardwareQuirk, 106> kHardwareQuirks = {
    HardwareQuirk{ "Note", "All ROMs must be 200ns or faster for Normal Speed.\nAll ROMs must be 120\"s or faster for High Speed.\n2.4 ROM DATA\nIn addition to the EP-ROMs, a copy of the ROM data must be submitted in binary\nformat on MS-DOS 3.5 inch disk(s). The size of the file must be equal to the size\nof the EP-ROM (i.e., one 4 Meg EP-ROM = one 4 Meg file).\n2.5 GAME PLAY VIDEO TAPE/RATING CERTIFICATE\nA video tape containing complete game play is required unless the product has\nbeen rated by the Entertainment Software Ratings Board (ESRB). If the product\nhas been rated by the ESRB, then a copy of the rating certificate must accompany\nthe submission and no video tape is needed.\n2.6 SCREEN TEXT\nA printed copy of the complete screen text must be submitted.\n2.7 INSTRUCTION MANUAL\nComplete game play instructions must be submitted.\nNOTE: If any of these items are not satisfied, the program will be rejected\nand will not be submitted into the approval process until all criteria\nare met.\n1-2-2", "SNES_DEV_book1.md" },
    HardwareQuirk{ "Note", "If Licensor approval is required, please assure that this has\nbeen finalized before the software submission has been made.\n23. Display of Super Famicom symbols or controllers in Super NES\ngames.\n2.8.4 A NOTE ON OBJECTIONABLE MATERIAL\nA copy of the Nintendo \"Game Content Guidelines\" is included in book 2 of\nthis manual. If you are unsure of whether an item of text or element of a\ngame is within Nintendo Software Standards, you may contact our Product\nAnalysis Department early in the development process and they will go\nover questionable items over the phone. In cases concerning an extensive\namount of text, please send it to the attention of NOA Product Testing Su\npervisor, using the address listed in the Preface of this manual, with the\nquestionable items highlighted. The material will be evaluated and you will\nbe contacted within a week to ten days.\n1-2-5", "SNES_DEV_book1.md" },
    HardwareQuirk{ "NOTE", "D\nD\nD\nD\nD\nD\nD\nD\nD\nEvaluation\nApproval Ver. __\nSpecification Sheet\n1 Set of ROMs\n(These must be specific EP-ROM type.\nSee Submission Requirements.)\nMS-DOS~ 3 1/2 Disk(s) (Files must be in binary\nformat. ::see Submission Requirements for\nspecific information.)\n1 copy of Custom DSP IC if applicable\n(Super NES Submissions Only)\n1 Copy of VHS Tapes or ESRB Rating\nCertificate\nScreen Text\nInstruction Manual or Game Play Instructions\nThis check list must be included with the software submis\nsion. If any of these items are not satisfied, the program will\nbe promptly returned and will not be submitted into the ap\nproval process until all criteria are met.\n1-2-6", "SNES_DEV_book1.md" },
    HardwareQuirk{ "Note", "When more than one ROM is required for the game program, all ROMs\nsubmitted as a set should be the same part number.\n9. Remarks\n\n\nIf a special configuration of game pak is used, please note the special configu\nration here. Write the name of the evaluation board which was used for debug\nging the game. Please write the full name as printed on the board. For\nexample,\nSHVC-4PVS8-10\nIf several boards were used for debugging the game, all boards must be listed .\n1-2-12", "SNES_DEV_book1.md" },
    HardwareQuirk{ "Note", "The RAM image is different from the production PCB.\nIf you buy PLD, you can use 8 Mbit EPROMs. Maximum ROM size will be 24 Mbits (8 Mbit x 3).\nPCB Configuration Mapping Usable EPROMs ROM Size\n20 or 21 4M/SM*1 4/S/12/16M(S/16/24M*1 )\n--_.- - -- -----\nI , R:R\n0,0 I , I\nm m a a\n9 9\ne ' e\nm m a a\n9 9 e ' e\n__ M'M\n, I FD I 14: 3\nRAM\nI ' I m'm a ' a g , g\ne : e\nI ' I m'm\na ' a g , g\ne ' e RAM\nUsable RAM\nNone/16K164K1256K\nBank 70-77\n, '7FFFH\n256K\nEnlarged\nRAM Area\nThe image of bank 70 is generated\nin bank 71-7D and FO-FF.\nUsable RAM\nNone/16K164K1256K\nEnlarged RAM Area\ni 3F 30\nffi]... , 8000H\nt- r,- + i r,-,-' 7800H\ni r,- t- r r,- ...J 7000H\ni,- - t- r,- -' 4\\,. 6800H\n. (' '16K) 6000H\n3F 30\n[ill ... I \" ;,;':>,\",',1 8000H\n: :: :::,: il:!il\n... 1 ! f tl 6000H\n(64K)\n3F 3C 33 30\nD:: ::::: (256K)\nThe shaded area indicates RAM\narea. Dotted area is RAM image.\nC/)\n~\n~\nm\nC/)\no\n~\n~\nC/)\n~\n~ C/)\n<5\n~\nlJ\n2j\nc:\n~\n~\n~", "SNES_DEV_book1.md" },
    HardwareQuirk{ "Note", "Use COOOH/8000H for a port to\nread from and write to OSP.\n~\nrn\n~\n~ r-\no\n~\n~\n-i\n~\n~\n~ r-", "SNES_DEV_book1.md" },
    HardwareQuirk{ "Note", "Use COOOH/8000H for a port to\nread from and write to OSP.\nC/)\n~\n~\nill\nC/)\no\n~\n~\nC/)\n~\n~\n~\na <:\n~\nS lJ\n~\n~\n~", "SNES_DEV_book1.md" },
    HardwareQuirk{ "Note", "Use 4000H/OOOOH for a port to\nread from and write to DSP.\n~\nm\n~\n~ t-\nO\n~\n~ ..,\n~ <:\n~\nt-", "SNES_DEV_book1.md" },
    HardwareQuirk{ "Note", "Use COOOH/8000H of bank 3F for a port to\nread from and write to DSP when\nthe ROM size is 8M or less.\n~\nrn\n~\n~ r-\no\n~\n~\n-i\n~ <:\n~ r-", "SNES_DEV_book1.md" },
    HardwareQuirk{ "Note", "Use 4000H/0000H for a port to\nread from and write to OSP.\nI\nI\nI\nC/)\n~\n~\n~\nm\nC/)\no\n~\n~\nC/)\n~\n~\n~\no <:\nlJ\n~\n~\n~ CJj", "SNES_DEV_book1.md" },
    HardwareQuirk{ "Note", "Use 7000H/6000H for a port to\nread from and write to DSP.\n~\nrn\n~\n~ r-\no\n~\n~\n-i\n~\n~\n~ r-", "SNES_DEV_book1.md" },
    HardwareQuirk{ "Note", "Use EPROM listed above or one with the same pin locations.\n1M-32M 4M-32M COMMENT\n20/21/0SP 23/SA-1 FIELD\n-- --\n(J) -- w/back-up\n-- \nREMARKS\n64K SRAM Installed\n25 Units per Kit\nUp to 24M by changing PLD\n25 Units per Kit\nUp to 24M by changing PLD\n1M SRAM Installed\n256K SRAM Installed\n1 M SRAM Installed\nI\nCJ)\n~\nm\nCJ)\no\n~\n~\nCJ)\nai\n~\n~\n~\n~\n~\n~\n~\nCri", "SNES_DEV_book1.md" },
    HardwareQuirk{ "Note", "Back-up RAM sizes of 512K bit and 1 M bit are under development. If required, contact NOA Licensing\nDepartment.\n~\nm\n~\n~ r-\no\n~\n~\n-i\n~\n~\n~ r-", "SNES_DEV_book1.md" },
    HardwareQuirk{ "Note", "Back-up RAM sizes of 512K bit and 1 M bit are under development. If required, contact NOA Licensing\nDepartment.\nC/)\n~\n~\nm\nC/)\nQ\n~\nlJ I'll\nC/)\n~\n~ C/)\nC/)\n<5\n~\nlJ\n~ c: )j\n~\n~", "SNES_DEV_book1.md" },
    HardwareQuirk{ "CAUTION", "It is prohibited to write \"1 OOH\" to the \"OAM H-posnion (9-bit)\n(Refer to page A-4)\n(NCL PGS)\n2-2-2", "SNES_DEV_book1.md" },
    HardwareQuirk{ "NOTE", "When the main screen data is the OBJ, it will be added to or\nsubtracted from the sub screen data only for the OBJ of the pallet\ncode (4 to 7).\nNOTE: When \"1/2 Enable\" of register <2131 H> is enabled, the addition/\nsubtraction result of each RGB becomes 1/2.\n(NCL PC 14)\n2-7-3", "SNES_DEV_book1.md" },
    HardwareQuirk{ "NOTE", "See page A-17 for color data.\n(NCLPG 17)\n2-8-1", "SNES_DEV_book1.md" },
    HardwareQuirk{ "NOTE", "B means the data of register <43X1 H>\n(NCL PC 28)\n2-17-2", "SNES_DEV_book1.md" },
    HardwareQuirk{ "NOTE", "8 means the data of register <43X1 H>.\n(NeL PC 30)\n2-17-4", "SNES_DEV_book1.md" },
    HardwareQuirk{ "NOTE", "\"The number of displayed OBJs\" counts OBJs hidden by BG window or\nother OBJs.\nNOTE: If H-position is minus, and the OBJ is not displayed on the screen area\n(located on the left of the screen to be displayed), \"the number of displayed OBJs\"\ndoes not count them.\n20.2 35'S TIME OVER\nThe other limitation on the horizontal line is called \"35's time over.\" This limits the\nnumber of OBJs (converted to character size 8-dot x 8-dot) that can be displayed.\nIf the \"35's Time Over\" has occurred in one field (at least one line), \"07\" of the reg\nister <213EH> will be set. In the line in which this \"35's Time Over\" has occurred,\nonly 32 of the total OBJs available can be displayed according to the priority order\n(selected from larger OBJ number). This limit is due to a conversion limit of less\nthan 35 OBJs (8 x 8) displayed per horizontal line. \"These 32 OBJs must satisfy\nthe display condition explained in \"33's Range Over\", above.\nNOTE: There are characters (8-dot x 8-dot) which are not displayed on the dis\nplay area depending on OBJ size and position. But they are not included in this\nlimitation (34 or less).\n(NCL PC 34)\n2-20-1", "SNES_DEV_book1.md" },
    HardwareQuirk{ "Note", "1 field (16.6 msec)\n2-24-4", "SNES_DEV_book1.md" },
    HardwareQuirk{ "Note", "0 = Off\n1 = On\n0 1\n0 1\n1 1 1 1\n0 0 0 0\n2-24-5\n0 0 0 0 1 1 1 1 0 0\n0 0 0 0 1 0 0 0 0 0", "SNES_DEV_book1.md" },
    HardwareQuirk{ "Note", "1 field (16.6 msec)\n2-24-7", "SNES_DEV_book1.md" },
    HardwareQuirk{ "NOTE", "The data can be written only during V-BLANK or FORCED BLANK period.\n(NeL PG52)\n2-27-7", "SNES_DEV_book1.md" },
    HardwareQuirk{ "NOTE", "After the address is set, the data should be written in the or\nder of low, then high. This is similar to the OAM Data register.\nNOTE: The data can be written only during H/V BLANK or FORCED\nBLANK period.\n(NeL PC 55)\n2-27-11", "SNES_DEV_book1.md" },
    HardwareQuirk{ "NOTE", "If 'LEFT POSITION SETTING VALUE> RIGHT POSITION VALUE\" is assumed, there will\nbe no range of the window.\n(NeL PC 56)\n2-27-12", "SNES_DEV_book1.md" },
    HardwareQuirk{ "NOTE", "\"IN/OUT\" of registers <2123H> <2124H> <212SH> becomes the \"NOT logic\" for each\nWindow-1 and Window-2.\n(NCL PC 57)\n2-27-13", "SNES_DEV_book1.md" },
    HardwareQuirk{ "NOTE", "When the screen addition/subtraction is functioning, the SUB screen is a screen\nto be added or subtracted against the MAIN screen.\n(NeL PC 58)\n2-27-14", "SNES_DEV_book1.md" },
    HardwareQuirk{ "NOTE", "When the screen addition/subtraction is functioning, the SUB screen is a screen\nto be added or subtracted against the MAIN screen.\n(NeL PC 59)\n2-27-15", "SNES_DEV_book1.md" },
    HardwareQuirk{ "Note", "When OBJ is designated, the Addition/Subtraction\nfunction is available only when the OBJ color palette is 4\nthrough 7.\n~ \"1/2 OF COLOR DATA\" DESIGNATION:\nWhen color constant addition/subtraction or screen addition/\nsubtraction is performed, designate whether the RBG result in the\naddition/subtraction area should be \"1/2\" or not. The back\n(color constant) area on the Subscreen, will not become \"1/2\"\n-0 : DISABLE\nL 1 : ENABLE (1/2 function: ON)\nL.....-----1~~ COLOR DATA ADDITION/SUBTRACTION SELECT:\nIn the case of executing screen\naddition/subtraction designate\neither addition or subtraction mode.\n[ 0: ADDITION MODE SELECT\n1 : SUBTRACTION MODE SELECT\n(NeL PC 60)\n2-27-17", "SNES_DEV_book1.md" },
    HardwareQuirk{ "NOTE", "The data can be read only during HN BLANK or FORCED BLANK period.\nADDRESS: 2139H / 213AH\nNAME: *VMDATAL / *VMDATAH\nCONTENTS: READ DATA FROM VRAM\nD7\nD7\nD1S I\nD6 DS D4 D3 D2 D1 DO\nVRAM DATA (LOW)\nI 2139H\nD6 DS D4 D3 D2 D1 DO\nVRAM DATA (HIGH)\n213AH\nD14 I D13 I D12 I D11 I D10 I D9 I D8\nThis is a register, which can read the data at any address of the VRAM.\nThe initial address should be set by registers <2116> and <2117H>. The data can\nbe read by the address which has been set initially.\nWhen reading the data continuously, the first data for the address increment\nshould be read as \"dummy\" data after the address has been set.\nQuantity to be increased will be determined by \"SC INCREMENT\" of register\n<211SH> and the setting value of the \"FULL GRAPHIC.\"\nNOTE: The data can be read only during HN BLANK or FORCED BLANK period.\n(NeL PC 63)\n2-27-21", "SNES_DEV_book1.md" },
    HardwareQuirk{ "Note", "The data can be read only during H/V blank or forced blank period.\nADDRESS: 213CH 1213DH\nNAME: *OPHCT I *OPVCT\nCONTENTS: H/V COUNTER OATA BY EXTERNAL OR SOFTWARE LATCH\n07 06\nH7\nV7\n05 04 03 02 01 00\nOUTPUT DATA OF H-COUNTER\n(H8) 213CH\nHO\nOUTPUT OATA OF V-COUNTER\n(V8) 213DH\nVO\nThe HN counter is latched by reading register <2137H>, and its H/V counter val\nue can be read by this register.\nThe H/V counter is also latched by the external latch, and its value can be read by\nthis register.\nIf register <213CH> or <2130H> is read after register <213FH> has been read,\nthe lower 8-Bit data will be read first, and then the upper 1-Bit will be read by\nreading the register.\n(NeL PC 64)\n2-27-22", "SNES_DEV_book1.md" },
    HardwareQuirk{ "NOTE", "The flag will be reset at the end of the V-BLANK period.\nADDRESS: 213FH\nNAME: *STAT78\nCONTENTS: PPU STATUS FLAG & VERSION NUMBER\n07 D6\nFIELD EXT.\nLATCH\n05 04\nNTSC\n/PAL\nD3 D2 D1 DO\n5C78 VERSION NUMBER\nl DISPLAY METHOD [0: NTSC\n1 : PAL\n213FH\nEXTERNAL LATCH FLAG: When the external signal (Light Pen, etc.) is applied, it\nenables to latch the HN counter value. It is connected to I/O port d7 In SNES.\n(Refer to page 1-28-1.)\nThis is a status flag, which indicates whether the 1 st or 2nd field is scanned at the interlace\nmode. (The definition is different from the field of NTSC.)\n[ 0 : 1ST FIELD\n1 : 2ND FIELD\nNOTE: When this register is read, registers <213CH> <213DH> will be initialized individually in the\norder of Low and High.\n(NeL PC 65)\n2-27-23", "SNES_DEV_book1.md" },
    HardwareQuirk{ "NOTE", "Because the data area (register<4300H> .... ) of each channel is held in common with the data\nof each H-DMA channel, the channel designated by the H-DMA channel designation register\n<420CH> can not be used. (It is prohibited to write \"1\" to the bit of the channel). Therefore 8\nchannels (CHO .... CH7) should be assigned by the H-DMA and the general purpose DMA.\nNOTE: If the H-Blank comes during the operation of the general purpose DMA and the H-DMA is\nstarted, the general purpose DMA will be discontinued in the middle and resumed right after\nthe H-DMA is complete.\nNOTE: If 2 or more channels are designated, the DMA transfer will be performed continuously\naccording to the priority order described on page B-1. The CPU will also stop operation until\nall the general purpose DMAs are completed.\n(NeL PC 91)\n2-28-4", "SNES_DEV_book1.md" },
    HardwareQuirk{ "NOTE", "Once this flag is set, it will not be cleared until new data is set.\nThe initial settings are done automatically for every field and the same\ntransfer pattern will be repeated. The flag is also set out of V-Blank period,\nso the DMA transfer will be performed properly for the next screen frame.\nADDRESS : 420DH\nNAME : MEMSEL\nCONTENTS:ACCESS CYCLE DESIGNATION IN MEMORY (2) AREA (Refer to \"Memory Map\")\n07 D6 05 04 03 02 01 DO\n12'~81420DH\nACCESS CYCLE DESIGNATION IN MEMORY (2) AREA\n[\n0 : 2.68MHz access cycle\n1 : 3.58MHz access cycle (Only when the high speed memory is used)\n MEMORY (2) shows the address (8000H ,... FFFFH) of the bank (80H ,... BFH)\nand all the addresses of the bank (COH ,... FFH).\n When power is turned on or the reset signal is applied, it becomes \"0\".\n(NeL PC 91 <-'1' 91a)\n2-28-5", "SNES_DEV_book1.md" },
    HardwareQuirk{ "NOTE", "It is necessary to reset by reading this flag during NMI processing. (Refer to page B-3.)\nADDRESS :4211H\nNAME :* TIMEUP\nCONTENTS: IRQ FLAG BY H/V COUNT TIMER\nD7 D6 D5 D4 D3 D2 D 1 DO\n4211 H\nTRQ FLAG BY HN COUNT TIMER:\nThis flag is \"READ RESET\". (If Timer Enable is set by \"Timer Enable\" of register <4200H>,\nIRQ will be applied and the flag will be set as soon as HN count timer reaches the value\nstored.\n* Even if V-EN =\"0\" and H-EN =\"0\" are set by \"Timer Enable\" of register <4200H>, this flag will be\nreset.\n[\n0 : Either H/V count timer is active or disabled\n1 : Status of HN count timer is Time-Up\n(NCL PC 92)\n2-28-6", "SNES_DEV_book1.md" },
    HardwareQuirk{ "NOTE", "Whether the standard controllers are connected to Super NES unit or not can be determined\nby reading the 17th bit of 4016H and 4017H. (Refer to \"Standard Controller\".)\n[\n1 : connected\no : not co nnected\n(NCL PC 95)\n2-28-9", "SNES_DEV_book1.md" },
    HardwareQuirk{ "Note", "Clear Timing\nWhen Reset: \"--00-000\"\nPort clear is executed during the machine cycle following that in which \"1\"\nis written into the port clear control bit.\nWhen port clear timing conflicts with write timing to the port in question\nfrom the SNES bus, there are cases in which the contents of the register in\nquestion become indeterminate.\nI Machine Cycle I Machine Cycle I 4 ~4 ~\nClear Pulse\nTiming when \"1\" is written into the port clear control bit.\nFigure 3-4-2 Clear Timing\n(NCLPG 8)\n3-4-1", "SNES_DEV_book1.md" },
    HardwareQuirk{ "NOTE", "In regard to the functional operation of timers, please refer to the next\npage.\n(NeL PC 9)\n3-4-2", "SNES_DEV_book1.md" },
    HardwareQuirk{ "Note", "Modulation can not be imposed on this noise.\nNON\n(30H)\n07 06 05 04 03 02 01 DO\n(NeL PC 20)\n3-7-7", "SNES_DEV_book1.md" },
    HardwareQuirk{ "NOTE", "DAO .... DA7 are used for the character dot data. CLO .... CL2 are used for the BG-SC data of\nthe color. (However, in case of Mode-7, CLO .... CL2 should be \"0\")\nNOTE: If they are \"0,\" it becomes transparent. The color of CG-RAM address (OOH) will be\nbackground. (NeL PC 81)\nA-I7", "SNES_DEV_book1.md" },
    HardwareQuirk{ "NOTE", "In case of the display priority between the OBJ's, normally the lower numbered OBJ will\nbe displayed as higher priority. (See page 1-20-2 for exception.)\nThis display priority will be determined before the priority between OBJ and BG is determined.\nNOTE: In case of Mode 7, the priority is 0 at BG1.\n(NeL PC 83)\nA-19", "SNES_DEV_book1.md" },
    HardwareQuirk{ "NOTE", "1) V - RAM, OAM, & CG - RAM is omitted.\n2) ( ) shows name of register.\n~ c:\n~\nG)\nCi.i\nrr1\n~", "SNES_DEV_book1.md" },
    HardwareQuirk{ "Note", "The number of cycles of conditional branching commands are appropriate\nto cases when there is no branching to the left side and there is branching to the\nright side.\nTable C-3 Explaination of Symbols in the Status Flag Column\nSymbol Meaning\nNo Change\n0 Cleared to \"0\"\n1 Set to \"1\"\nFlag Name Set or Cleared Depending on Result\n(NeL PC 36)\nC-2", "SNES_DEV_book1.md" },
    HardwareQuirk{ "Note", "The same image is mapped to all areas, (i.e.,\n00:6000H-00:7FFFH, 01 :6000H-01 :7FFFH ....\nBF:6000H-BF:7FFFH).\n1-4-14\nFFFFH\naOOOH\n6000H\nOOOOH", "SNES_DEV_book2.md" },
    HardwareQuirk{ "Note", "The same image is mapped to a\" areas, (Le.,\n00:6000H-00:7FFFH, 01 :6000H-01 :7FFFH ....\nBF:6000H-BF:7FFFH).\n1-4-15", "SNES_DEV_book2.md" },
    HardwareQuirk{ "NOTE", "Store a \"1\" in ACM to clear the result register during cumulative\nsum operations.\n1-4-26", "SNES_DEV_book2.md" },
    HardwareQuirk{ "NOTE", "Reading this register does not clear its contents.\n1-4-30", "SNES_DEV_book2.md" },
    HardwareQuirk{ "NOTE", "Reading this register does not clear its contents.\n1-4-31\n2301H", "SNES_DEV_book2.md" },
    HardwareQuirk{ "NOTE", "The registers indicated in the following steps are set using the\nSuper NES CPU.\nSTEP 2. Specify the SA-1 OMA transmission source address using the Super\nNES CPU.\nStore the transmission source address (BW-RAM) in SOA\n(2232H-2234H).\nA specific number of low bit of the address must be set to \"0\",\nas a function of the color mode and the number of horizontal\ncharacters set in SIZEO-2 of CDMA (2231 H). The specific\nnumber of \"0\" bits can be determined from the table below.\nColor Mode 4 4 4 4 4 4 16 16 16 16 16 16 256 256 256 256 256 256\nNumber of\nHorizontal 1 2 4 8 16 32 1 2 4 8 16 32 1 2 4 8 16 32\nCharacters\nZero Bits 4 5 6 7 8 9 5 6 7 8 9 10 6 7 8 9 10 11\nTable 1-6~2 Number of Zero Bits in BW-RAM\nSTEP 3. Set COMA (2231 H) using the Super NES CPU.\nStore the color mode (4, 16, or256) in CBO and CB1.\nStore the number of virtual VRAM horizontal characters in\nSIZEO-2.\nSTEP 4. Specify the SA-1 I-RAM address for the buffers as the transmission\ndestination.\nNOTE:\nStore the buffer address in DOA (2235H and 2236H).\nIt is not necessary to set 2237H because I-RAM is specified.\nThe lowest 5 bits of the I-RAM address must all be \"0\" for 4 col\nor mode. The lowest 6 bits of the I-RAM address must be \"0\"\nfor 16 color mode. And, the lowest 7 bits of the I-RAM address\nmust be \"0\" for 256 color mode.\n1-6-8", "SNES_DEV_book2.md" },
    HardwareQuirk{ "Note", "(S) indicates signed data and (U) indicates unsigned data.\nThe type of arithmetic operation is specified in the arithmetic operation control\nregister (**2250H) using the SA-1 CPU. The user should choose between ACM\n(d1) for cumulative sum operations and MID (dO) for multiplication or division op\nerations. The required number of cycles for each operation are shown below.\nArithmetic ACM MID Number of Cycles Operation\nMultiplication 0 0 5\nDivision 0 1 5\nAccumulative 1 - 6\nTable 1-7-1 Arithmetic Operations Settings and Cycles\nThe number of cycles is calculated based upon 10.74 MHz per cycle.\n1-7-1", "SNES_DEV_book2.md" },
    HardwareQuirk{ "NOTE", "Store the transmission source device in bits SDO and SD1.\nStore the transmission destination device in bit DD.\nThe same device cannot be used for source and destination.\nSource Device Destination Device\nNOTE:\nSD1 SDO Device DD Device\n0 0 Game Pak ROM 0 SA-1 I-RAM\n0 1 BW-RAM 1 BW-RAM\n1 0 SA-1 I-RAM\nStore the transmission mode in bit CDEN.\nCDEN=O: Normal DMA\nCDEN=1: Character Conversion DMA\nSet DPRIO (d6) to assign priority between SA-1 CPU and\nDMA.\nDPrio=O:\nDPrio=1 :\nSA-1 CPU priority (Instructions can be exe\ncuted during transmission)\nDMA priority (SA-1 CPU waits during DMA)\nThe DPrio setting is only valid during Normal DMA between BW\nRAM and SA-1 I-RAM.\nSet DMAEN to enable or disable DMA.\nDMAEN=O: DMA disable (DMA is not used)\nDMAEN=1: DMA enable (Use DMA, clear parameters)\nWhen setting the DMA parameters, first set DMAEN=1 from\nthe SA-1 CPU and then set the other parameters. Set\nDMAEN=O after the DMA has been completed.\n1-9-2", "SNES_DEV_book2.md" },
    HardwareQuirk{ "Note", "Pipeline and cache circuits enable high speed execution of instruc\ntions.\n2.1.3 GAME PAK ROM CONTROLLER\nThe game pak ROM controller performs the following functions:\n1. Controls data transfer between the Super NES CPU and\ngame pak ROM.\n2. Loads instructions from game pak ROM to the GSU.\n3. Transfers data from the game pak ROM to the GSU internal\nregisters.\nNote: Data transfer from the game pak ROM to the GSU is accom\nplished using a ROM buffering system. This enables instructions\nfrom the game pak RAM and cache to be executed and operated\nin an array.\n2.1.4 GAME PAK RAM CONTROLLER\nThe game pak RAM controller functions as follows:\n1. Controls data transfer between the Super NES CPU and\ngame pak RAM.\n2. Loads instructions from game pak RAM to the GSU.\n3. Transfers data between game pak RAM and GSU internal\nregisters.\n4. Bitmap emulation.\nNote: Data transfer from the game pak RAM to the GSU is accomplished\nusing a RAM buffering system. This enables instructions from the\ngame pak ROM and cache to be executed and operated in an ar\nray.\n2-2-2", "SNES_DEV_book2.md" },
    HardwareQuirk{ "Note", "The GSU is equipped with sixteen, 16-bit registers. All GSU opera\ntions are performed using the general registers.\n2.1.6 OPERATOR\nThe Operator executes 16-bit arithmetic operations and logical opera\ntions.\n2.2 REGISTERS\nA list of GSU internal registers is provided in the table below.\nFUNCTIONAL GROUP REGISTER NAME\nGeneral Registers General Register RD .... R13\nROM Address Pointer R14 Group Program Counter R15\nStatus/Flag Register SFR\nProgram Bank Register PBR\nGame Pak ROM\nRegisters Related to Bank Register ROMBR\nMemory Operations Game Pak RAM\nBank Register RAMBR\nCache Base Register CBR\nScreen Base Register SCBR\nPlot Related Registers Screen Mode Register SCMR\nColor Register COlR\nPlot Option Register POR\nBack-up RAM Register BRAMR\nOther Registers Version Code Register VCR\nCONFIG Register CFGR\nClock Select Register ClSR\nTable 2-2-1 Registers Listed by Functional Group\n2.2.1 GENERAL REGISTERS\n2.2.1.1 RD .... R13\nThese registers are used to execute various instructions as GSU\nGeneral Registers during GSU operation. There are special\nfunctions available for some instructions (refer to \"GSU Internal\nRegister Configuration\"). These can also be accessed by the Su\nper NES CPU when the GSU is in the idle state.\n2-2-3", "SNES_DEV_book2.md" },
    HardwareQuirk{ "Note", "The PBR can be used to specify any bank address that is mapped.\nThe ROMBR can only be used to specify banks OOH to 5FH.\nA\nM\nE\nP\nA\nK\nR\nA\nM\n(8)\nfV1\nROM (A)\n @'~'~\n~\"\"@~<D\nPAK\nROM\nIMAGE\n(A')\n.....\n~\"'\")\"\"\"\"\" '\" > '\" .,aOOOH\n.... @'eD'\n6000H\n4000H\n3300H\n3000H\n2000H\nI I\" , , )I , \" \" 10000H\n~\n~\n~ -<\n~\n\\J\n~\n~", "SNES_DEV_book2.md" },
    HardwareQuirk{ "Note", "When the Super FX operates at 21 MHz (when the ClSR flag of the\nClock Select Register is \"1 \"), MSO flag should be fixed at \"0\".\n4.16 CLOCK SELECT REGISTER (CLSR)\nAccess from Super NES CPU:\nSuper NES CPU Addresses:\nRegister Size:\nOefault Address:\nGSU Access Method:\n07 06 05\nWhen:\nW\n**:3039H\n1 bit\nOOH\nNone\n04 03\nClSR Flag = 0, Super FX operates at 10.7 MHz\n= 1, Super FX operates at 21.4 MHz\n02\nThis register assigns the Super FX operating frequency.\n2-4-11\n01 00\nI %~: I 3039H", "SNES_DEV_book2.md" },
    HardwareQuirk{ "Note", "RON absolutely must be set to \"1\".\n CFGR (Super NES CPU Address, **:3037H)\n ClSR (Super NES CPU Address, **:3039H\nSubsequently, when the lead address of the GSU program is\nwritten from the Super NES CPU to R15 (Super NES CPU ad\ndress, **:301 EH), the GSU can be started from that address.\nAn example of the program required for starting the GSU from\nthe Super NES is demonstrated on the following page.\n2-5-1", "SNES_DEV_book2.md" },
    HardwareQuirk{ "Note", "RAN absolutely must be set to \"1\".\n CFGR (Super NES CPU Address, **:3037H)\n ClSR (Super NES CPU Address, **:3039H)\nSubsequently, when the lead address of the GSU program is\nwritten from the Super NES CPU to R15 (Super NES CPU ad\ndress, **:301 EH), the GSU can be started from that address.\n2-5-2", "SNES_DEV_book2.md" },
    HardwareQuirk{ "Note", "If the game pak ROM is accessed from the Super NES CPU dur\ning GSU operation when GO and RON are \"1\", the dummy data\ncan be read using the value of the lower 4 bits of that address.\nThis will generate the dummy addresses described above. The ta\nble below demonstrates this.\nLower 4 Bits of Address Dummy Data\nOH, 2H, 6H, 8H, CH OOH\n4H 04H\nAH 08H\nEH OCH\nOther OIH\nTable 2-5-2 Dummy Data\n5.4.2 INTERRUPT FROM GSU TO SUPER NES CPU\nThe STOP instruction generates an IRQ from the GSU to the Super NES\nCPU. Therefore, the Super NES CPU can continue its own processing\nwithout having to periodically monitor the GSU for the end of its routine.\nSince there are instances in which an I RQ is generated for some other\nreason, the Super NES CPU must determine if the GSU was the source\nof the IRQ. There is an IRQ flag at bit 15 of the GSU status register. If this\nflag is \"1\", the IRQ was generated by the completion of GSU processing.\nWhen bit 15 of this status register is read, the bit is reset to \"0\". The IRQ\noutput by the GSU can be disabled by setting bit 7 in the CON FIG regis\nter to \"1\".\n2-5-5", "SNES_DEV_book2.md" },
    HardwareQuirk{ "Note", "Be especially careful when placing an instruction of 2 bytes or more after\nan instruction that changes the program counter.\n(Example 2)\nLOP1:\nBNE LOP1\nBRA LOP2\nTO R1\nWhen the program in Example 2 is executed, the program jumps to LOP1 when\nthe Z flag is 0, but the first byte of the code \"BRA LOP2\" has already been loaded\ninto the pipeline. Therefore, the code 11 H at the jump destination \"TO R1\" wilt be\nprocessed as the offset value of the BRA instruction, causing \"BRA ****\" to be ex\necuted instead of \"TO R 1\".\nNote: The value for **** = LOP1 + 1 + 11 H.\nIn this situation, a NOP instruction should be inserted after the BNE instruction, as\nshown below.\n(Example 3)\nLOP1:\nBNE LOP1\nNOP\nBRA LOP2\nTO R1\n2-6-2", "SNES_DEV_book2.md" },
    HardwareQuirk{ "Note", "Machine Cycles:\nIf CY Flag=O\nDESCRIPTION OF INSTRUCTIONS\n(e= -128 -+ 127)\nR15 identifies the next\naddress for the BCC\ninstruction (2 bytes)\nIf the carry flag is \"0\", add \"e\" to the contents of the program\ncounter R15 and JUMP to the address indicated by the resulting\nvalue in the program counter.\nIf the carry flag is \"1\", do not jump.\nThe relative offset can be -128 to + 127 bytes from the address\nfollowing the code for \"e\".\nIf the decision results in a JUMP, the next instruction to be exe\ncuted will already be in the instruction pipeline of the processor.\nFor this reason one byte from the pipeline will be executed be\nfore the instruction at the branch destination is executed. (The\nexecution time for this instruction is not included in the machine\ncycles listed below.)\nCY z\nNo flags affected\n(MSB) (LSB)\no I 0 I (OCH)\n--.... ~ Relative address\nThe number \"e\" (number, label, formula) which shows the jump\ndestination is given in the assembler as an operand.\nROM execution time 6 cycles\nRAM execution time 6 cycles\nCache RAM execution time 2 cycles\n2-9-14", "SNES_DEV_book2.md" },
    HardwareQuirk{ "Note", "Machine Cycles:\nThe number \"e\" (number, label, formula) which shows the jump\ndestination is given in the assembler as an operand.\nROM execution time\nRAM execution time\nCache RAM execution time\n2-9-16\n6 cycles\n6 cycles\n2 cycles", "SNES_DEV_book2.md" },
    HardwareQuirk{ "Note", "Machine Cycles:\naddress\nThe number \"e\" (number, label, formula) which shows the jump\ndestination is given in the assembler as an operand.\nROM execution time 6 cycles\nRAM execution time 6 cycles\nCache RAM execution time 2 cycles\n2-9-18", "SNES_DEV_book2.md" },
    HardwareQuirk{ "Note", "Machine Cycles:\nIf (S XOR ON)=O\nDESCRIPTION OF INSTRUCTIONS\n(e= -128 .... + 127)\nR15 identifies the next\naddress for the BGE\ninstruction (2 bytes)\nIf the sign flag and the overflow flag are equal, add \"e\" to the pro\ngram counter R15 and JUMP to the address indicated by the re\nsulting value in the program counter.\nIf the values are different, do not jump.\nThe relative offset can be -128 to + 127 bytes from the address\nfollowing the code for \"e\".\nIf the decision results in a JUMP, the next instruction to be exe\ncuted will already be in the instruction pipeline of the processor.\nFor this reason one byte from the pipeline will be executed be\nfore the instruction at the branch destination is executed. (The\nexecution time for this instruction is not included in the machine\ncycles listed below.)\nCY z\nNo flags affected\n(MSB) (LSB)\nI\n0 I 0 I 0 I 0 I 0 I 1 I 1 1 I (07H)\nt--... --'-----'-e-('--O-O-H.L...-.... -F-F-'--H-) ----'-~~~:.~---I Relative\n'---------------- _______________________ ~. address\nThe number \"e\" (number, label, formula) which shows the jump\ndestination is given in the assembler as an operand.\nROM execution time 6 cycles\nRAM execution time 6 cycles\nCache RAM execution time 2 cycles\n2-9-20", "SNES_DEV_book2.md" },
    HardwareQuirk{ "Note", "Machine Cycles:\naddress\nThe number \"e\" (number, label, formula) which shows the jump\ndestination is given in the assembler as an operand.\nROM execution time 6 cycles\nRAM execution time 6 cycles\nCache RAM execution time 2 cycles\n2-9-24", "SNES_DEV_book2.md" },
    HardwareQuirk{ "Note", "Machine Cycles:\nIf S Flag = 1\nDESCRIPTION OF INSTRUCTIONS\n(e= -128-+ 127)\nR15 identifies the next\naddress for the BM I\ninstruction (2 bytes)\nIf the sign flag is \"1\", add \"e\" to the program counter R15 and\nread the next instruction at the location indicated by the resulting\nvalue in the program counter.\nIf the sign flag is \"0\", do not jump.\nThe relative offset can be -128 - + 127 bytes from the address\nfollowing the code for \"e\".\nIf the decision results in a JUMP, the next instruction to be exe\ncuted will already be in the instruction pipeline of the processor.\nFor this reason one byte from the pipeline will be executed be\nfore the instruction at the branch destination is executed. (The\nexecution time for this instruction is not included in the machine\ncycles listed below.)\nz\nNo flags affected\n(MSB) (LSB)\nI\n0 I 0 I 0 I 0 I 1 I 0 I 1 I 1 I (OBH)\n... e (OOH-FFH) .. Relative\nL...-- ____________ --'. address\nThe number \"e\" (number, label, formula) which shows the jump\ndestination is given in the assembler as an operand.\nROM execution time\nRAM execution time\nCache RAM execution time\n2-9-26\n6 cycles\n6 cycles\n2 cycles", "SNES_DEV_book2.md" },
    HardwareQuirk{ "Note", "Machine Cycles:\nIf Z Flag = 0\nDESCRIPTION OF INSTRUCTIONS\n(e= -128-+ 127)\nR15 identifies the next\naddress for the BNE\ninstruction (2 bytes)\nIf the zero flag is \"0\", add \"e\" to the program counter R15 and\nread the next instruction at the location indicated by the resulting\nvalue in the program counter.\nIf the zero flag is \"1\", do not jump.\nThe relative offset can be -128 - + 127 bytes from the address\nfollowing the code for \"e\".\nIf the decision results in a JUMP, the next instruction to be exe\ncuted will already be in the instruction pipeline of the processor.\nFor this reason one byte from the pipeline will be executed be\nfore the instruction at the branch destination is executed. (The\nexecution time for this instruction is not included in the machine\ncycles listed below.)\nCY Z\nNo flags affected\n(MSB) (LSB)\nI\n0 I 0 I 0 I 0 I 1 I 0 I 0 I 0 I (08H)\n... e (OOH-FFH)  Relative\n~------__________________ ~. address\nThe number \"e\" (number, label, formula) which shows the jump\ndestination is given in the assembler as an operand.\nROM execution time 6 cycles\nRAM execution time 6 cycles\nCache RAM execution time 2 cycles\n2-9-28", "SNES_DEV_book2.md" },
    HardwareQuirk{ "Note", "Machine Cycles:\nIf S Flag = 0\nDESCRIPTION OF INSTRUCTIONS\n(e= -128-+ 127)\nR15 identifies the next\naddress for the BPL\ninstruction (2 bytes)\nIf the sign flag is \"0\", add \"e\" to the program counter R15 and\nread the next instruction at the location indicated by the resulting\nvalue in the program counter.\nIf the sign flag is \"1\", do not jump.\nThe relative offset can be -128 - +127 bytes from the address\nfollowing the code for \"e\".\nIf the decision results in a JUMP, the next instruction to be exe\ncuted will already be in the instruction pipeline of the processor.\nFor this reason one byte from the pipeline will be executed be\nfore the instruction at the branch destination is executed. (The\nexecution time for this instruction is not included in the machine\ncycles listed below.)\nCY z\nNo flags affected\n(MSB) (LSB)\nI\n0 I 0 I 0 I 0 I 1 I 0 I 1 I 0 I (OAH)\n~ e (OOH-FFH) .. Relative\nL...-- ____________ -..J. address\nThe number \"e\" (number, label, formula) which shows the jump\ndestination is given in the assembler as an operand.\nROM execution time\nRAM execution time\nCache RAM execution time\n2-9-30\n6 cycles\n6 cycles\n2 cycles", "SNES_DEV_book2.md" },
    HardwareQuirk{ "Note", "Machine Cycles:\nDESCRIPTION OF INSTRUCTIONS\n(e= -128-+ 127)\nR15 identifies the next\naddress for the BRA\ninstruction (2 bytes)\nRegardless of the status of the flags, add \"e\" to the program\ncounter R15 and read the next instruction at the location indicat\ned by the resulting value in the program counter.\nThe relative offset can -128 - +127 bytes from the address fol\nlowing the code for \"e\".\nWhen a JUMP occurs, the next instruction to be executed will al\nready be in the instruction pipeline of the processor. For this rea\nson one byte from the pipeline will be executed before the\ninstruction at the branch destination is executed. (The execution\ntime for this instruction is not included in the machine cycles list\ned below.)\nCY z\nNo flags affected\n(MSB) (LSB)\nI\n0 I 0 I 0 I 0 I 0 I 1 I 0 I 1 I (05H)\n~ e (OOH-FFH) ~ Relative\nL-________________________ ~. address\nThe number \"e\" (number, label, formula) which shows the jump\ndestination is given in the assembler as an operand.\nROM execution time 6 cycles\nRAM execution time 6 cycles\nCache RAM execution time 2 cycles\n2-9-32", "SNES_DEV_book2.md" },
    HardwareQuirk{ "Note", "Machine Cycles:\nIf ON Flag=O\nDESCRIPTION OF INSTRUCTIONS\n(e= -128-+127)\nR 15 identifies the next\naddress for the BVC\ninstruction (2 bytes)\nIf the overflow flag is \"0\", add \"e\" to the program counter R15 and\nread the next instruction at the location indicated by the resulting\nvalue in the program counter.\nIf the overflow flag is \"1\", do not jump.\nThe relative offset can be -128 - +127 bytes from the address\nfollowing the code for \"e\".\nIf the decision results in a JUMP, the next instruction to be exe\ncuted will already be in the instruction pipeline of the processor.\nFor this reason one byte from the pipeline will be executed be\nfore the instruction at the branch destination is executed. (The\nexecution time for this instruction is not included in the machine\ncycles listed below.)\nCY z\nNo flags affected\n(MSB) (LSB)\nI\n0 I 0 I 0 I 0 I 1 I 1 I 1 I 0 I (OEH)\n.... e (OOH-FFH) ~ Relative\n~------------------------~. address\nThe number \"e\" (number, label, formula) which shows the jump\ndestination is given in the assembler as an operand.\nROM execution time\nRAM execution time\n6 cycles\n6 cycles\nCache RAM execution time 2 cycles\n2-9-34", "SNES_DEV_book2.md" },
    HardwareQuirk{ "Note", "Machine Cycles:\nIf ON Flag=1\nDESCRIPTION OF INSTRUCTIONS\n(e= -128-+ 127)\nR15 identifies the next\naddress for the BVS\ninstruction (2 bytes)\nIf the overflow flag is \"1 \", add \"e\" to the program counter R15 and\nread the next instruction at the location indicated by the resulting\nvalue in the program counter.\nIf the overflow flag is \"0\", do not jump.\nThe relative offset can be -128 - +127 bytes from the address\nfollowing the code for \"e\".\nIf the decision results in a JUMP, the next instruction to be exe\ncuted will already be in the instruction pipeline of the processor.\nFor this reason one byte from the pipeline will be executed be\nfore the instruction at the branch destination is executed. (The\nexecution time for this instruction is not included in the machine\ncycles listed below.)\nz\nNo flags affected\n(MSB) (LSB)\nI\n~ I 0 I 0 I 0 I 1 1 1 I 1 I (OFH)\n.... iOiiii------- e (OOH-FFH) ----I.,.. Relative\n~------------_______________________ ~. address\nThe number \"e\" (number, label, formula) which shows the jump\ndestination is given in the assembler as an operand.\nROM execution time 6 cycles\nRAM execution time 6 cycles\nCache RAM execution time 2 cycles\n2-9-36", "SNES_DEV_book2.md" },
    HardwareQuirk{ "Note", "When transparency is on and the 4 bits to be plotted are\n\"0\", only the X coordinate is changed.\nBit 2 - Upper 4 Bits Color\nBit 2 is valid in the 16-color and 256-color modes. In the 256-col\nor mode, Bit 3 must be set to a logic \"1\".\nWhen Bit 2 is \"1\", the upper 4 bits in the source register are\nstored in the lower 4 bits of the color register while processing\nthe COLOR and GETC instructions. This allows the data for two\npixels to be stored in one byte.\nBit 3 - 256 Color Mode Only\nSet Bit 3, \"1\", in the 256-color mode to fix the upper 4 bits of the\ncolor register while processing the COLOR and GETC instruc\ntions and change the lower 4 bits only.\nBit 4 - Sprite Mode\nSet Bit 4, \"1\", to specify the bitmap in the sprite mode.\n2-9-39", "SNES_DEV_book2.md" },
    HardwareQuirk{ "Note", "Flags affected:\nDESCRIPTION OF INSTRUCTIONS\nSreg ~ Color register\nThis instruction loads the lower 8 bits of the source register into\nthe color register as the color value.\nThe value in the color register is stored in the color matrix (8\nrows x 8 columns) with the PLOT instruction. When the PLOT in\nstruction has been executed eight times or either of registers R1\nor R2 is changed, the data is changed automatically to character\ndata format and stored in the game pak RAM.\nB\nI A~T1 I A~T21 o~ I\nS CY Z\n0\nOpcode:\nCOLOR\nMachine Cycles:\nB : Reset\nALT1 : Reset\nALT2 : Reset\n(MSB)\n1 0 11 1 0 10 1 1\nROM execution time\nRAM execution time\n1\nCache RAM execution time\nExample: Under the following conditions:\nSreg: R6, R6= 9830H\n1\n(LSB)\nI 0 I (4EH)\n3 cycles\n3 cycles\n1 cycles\nthe color register becomes 30H when\nCOLOR\nis executed.\n2-9-42", "SNES_DEV_book2.md" },
    HardwareQuirk{ "Note", "Any register, Ro ... R1S, except R4 may be assigned as the\ndestination register.\nFlags affected:\nCY z\n* *\nB : Reset\nALT1 : Reset\nALT2 : Reset\nS : Set when the result is negative, else reset.\nCY : Set when Bit 15 of the result is \"1\"\nz\nOpcode: (MSB)\nand reset when \"0\".\n: Set if the upper 16 bits of result are zero,\nelse reset.\n(LSB)\nFMUL T I 1 I 0 0 1 1 1 1 I 1 I (9FH)\n2-9-46", "SNES_DEV_book2.md" },
    HardwareQuirk{ "Note", "Example:\nROM execution time\nRAM execution time\nCache RAM execution time\n11 or 7 cycles\n11 or 7 cycles\n8 or 4 cycles\nThe number of machine cycles depends on the CFGR register.\nUnder the following conditions,\nSreg: Rs, Dreg: R2, Rs= 4AAAH, R6= DAABH\nR2 becomes F51 CH and the carry flag and sign flag are set\nwhen\nFMULT\nis executed.\n2-9-47", "SNES_DEV_book2.md" },
    HardwareQuirk{ "Note", "RAM execution time 3-9 cycles\nCache RAM execution time 1-6 cycles\nBecause the ROM buffer is used, the number of execution cycles\nvaries with each program.\n2-9-49", "SNES_DEV_book2.md" },
    HardwareQuirk{ "Note", "Flags affected:\nOpcode:\nGETBH\nMachine Cycles:\nNote:\nDreg\nThis instruction loads the data contained in the ROM buffer to\nthe high byte of the destination register and the low byte of the\nsource register to the low byte of the destination register.\nThe source and destination registers are specified in advance\nusing a WITH, FROM, or TO instruction. When not specified,\nthese registers default to Ro.\nRefer to the GETB instruction and \"Memory Mapping\" for infor\nmation to load data from game pak ROM to the ROM buffer.\nCY z\nB : Reset\nALT1 :Res~\nALT2 :Res~\n(MSB) (LSB)\n1 ~I~I :1: I: 1:1 ~I :1\n(3DH)\n(EFH)\nROM execution time 6-10 cycles\nRAM execution time 6-9 cycles\nCache RAM execution time 2-6 cycles\nBecause the ROM buffer is used, the number of execution cycles\nvaries with each program.\n2-9-51", "SNES_DEV_book2.md" },
    HardwareQuirk{ "Note", "Flags affected:\nSreg\nDaD7 DO D7 ROM Buffer DO\nLower Byte I I      I I\nD8 D7 ~ DO\nLower Byte\nDreg\nThis instruction loads the data contained in the ROM buffer to\nthe low byte of the destination register and the high byte of the\nsource register to the high byte of the destination register.\nThe source and destination registers are specified in advance\nusing a WITH, FROM, or TO instruction. When not specified,\nthese registers default to Ro.\nRefer to the G ETB instruction and \"Memory Mapping\" for infor\nmation to load data from game pak ROM to the ROM buffer.\nB : Reset\nALT1 :Res~\nALT2 :Res~\nOpcode: (MSB) (LSB)\nGETBL I ~ I ~ I ~ I: I ~ I ~ I ~ I ~ I ~::::\nMachine Cycles:\nNote:\nROM execution time 6-10 cycles\nRAM execution time 6-9 cycles\nCache RAM execution time 2-6 cycles\nBecause the ROM buffer is used, the number of execution cycles\nvaries with each program.\n2-9-53", "SNES_DEV_book2.md" },
    HardwareQuirk{ "Note", "Flags affected:\nOpcode:\nGETBS\nMachine Cycles:\nNote:\nThis instruction loads the data contained in the ROM buffer to\nthe low byte of the destination register and the data contained in\nBit 7 of the ROM buffer to Bits 8-15 of the destination register.\nThe destination register is specified in advance using a WITH or\nTO instruction. When not specified, this register defaults to Ro.\nRefer to the GETB instruction and \"Memory Mapping\" for infor\nmation to load data from game pak ROM to the ROM buffer.\nCY z\nB : Reset\nALT1 :Res~\nALT2 :Res~\n(MSB) (LSB)\nROM execution time 6-10 cycles\nRAM execution time 6-9 cycles\nCache RAM execution time 2-6 cycles\nBecause the ROM buffer is used, the number execution cycles\nvaries with each program.\n2-9-55", "SNES_DEV_book2.md" },
    HardwareQuirk{ "Note", "Flags affected:\nOpcode:\nGETC\nMachine Cycles:\nNote:\nExample:\n(ROM buffer) -7 (COLOR register)\nThis instruction loads the data contained in the ROM buffer into\nthe color register as color data.\nRefer to the GETB instruction and \"Memory Mapping\" for infor\nmation to load data from game pak ROM to the ROM buffer. Re\nfer to COLOR and \"Bitmap Emulation\" for information concerning\nthe color register and how to plot.\nB : Reset\nALT1 : Reset\nALT2 : Reset\n(MSB)\nI 1 I 1 0 I 1 I 1 I\nROM execution time\nRAM execution time\n1\nCache RAM execution time\n1\nz\n(LSB)\nI 1 I (DFH)\n3-10 cycles\n3-9 cycles\n1-6 cycles\nBecause the ROM buffer is used, the number of execution cycles\nvaries with each program.\nUnder the following conditions,\n(ROM buffer) = 4BH\n4BH is loaded to the color register when\nGETC\nis executed.\n2-9-57", "SNES_DEV_book2.md" },
    HardwareQuirk{ "Note", "(Rm) -7 Dreg (Low Byte)\nOOH -7 Dreg (High Byte)\nDESCRIPTION OF INSTRUCTIONS\n(m=O-11)\nThis instruction loads one byte of data located at the game pak\nRAM address contained in the register specified in the operand\nRm and stores this data in the destination register. The upper\nbyte of the destination register is loaded with OOH.\nUse the RAMB instruction to set the RAM bank. (Refer to\nRAMB.)\nThe destination register is specified in advance using a WITH or\nTO instruction. When not specified, this register defaults to Ro.\nB\nALT1\nALT2\n(MSB)\n0\n0\n0 1\n1 0\n1\n0\n: Reset\n: Reset\n: Reset\nCY z\n(LSB)\n1 I 1 I 0 I 1\nm (OH-BH)\n(30H)\n(4mH)\nROM execution time 11 cycles\nRAM execution time 13 cycles\nCache RAM execution time 6 cycles\nThe GSU waits while the data is loaded from game pak RAM.\nThe cycles required for this are included in the execution times\ngiven above.\n2-9-64", "SNES_DEV_book2.md" },
    HardwareQuirk{ "Note", "Example:\nROM execution time 10 cycles\nRAM execution time 12 cycles\nCache RAM execution time 7 cycles\nWhile a load is performed from the game pak ROM, the GSU is\nin the WAIT state. This execution time is included in the above\nmachine cycles.\nUnder the following conditions,\nDreg:Rs, R3=6480H, (70:6480H)=COH, RAMBR=70H\nand when the following program is executed,\nLOW (R3)\nthe register Rs becomes C02EH.\n2-9-66", "SNES_DEV_book2.md" },
    HardwareQuirk{ "Note", "Example:\nRAM (xx) ~ Rn (low byte)\nRAM (xX1) ~ Rn (high byte)\nDESCRIPTION OF INSTRUCTIONS\n(n=0-15,xx=0-65535)\nWhen the value of xx is:\neven, (xx+ 1)\nodd, (xx-1)\nis loaded to the high byte.\nThis instruction loads the data contained in the game pak RAM\naddress specified in the second operand xx and stores the data\nin the register specified in the first operand Rn. The RAMB in\nstruction is used to specify the bank of the RAM address.\nB\nALT1\nALT2\n: Reset\n: Reset\n: Reset\nCY z\n(MSB) (LSB)\n0 0 1 1 1 I 1 I 0 I 1 (3DH)\n(FnH) 1 1 1 1 n (OH-FH)\nx (OOH-FFH)\nx (OOH-FFH)\nROM execution time\n(ADRS Lower Byte)\n(ADRS Upper Byte)\n20 cycles\nRAM execution time 21 cycles\nCache RAM execution time 11 cycles\nWhile a load is performed from the game pak RAM, the GSU is\nin the WAIT state. This execution time is included in the above\nmachine cycles.\nUnder the following conditions,\n(70:BACCH) = 28H, (70:BACDH) = 96H, RAMBR=70H\nregister Rg becomes 9628H when the following program is exe\ncuted:\nLM Rg, (OBACCH)\n2-9-70", "SNES_DEV_book2.md" },
    HardwareQuirk{ "Note", "Selectable RAM address (yy) must be an even number.\nThis instruction uses a short address method to perform the LM\ninstruction. The address is shortened by reducing the number of\nbytes in the instruction opcode. The instruction loads data from\nthe gamepak RAM address equal to the immediate number yy\nand stores the data in register Rn. The selectable game pak\nRAM address may be an even number of 0-510. The RAMS in\nstruction is used to specify the bank of the RAM address.\n0 0 1 1 1 I 1 I 0 I 1\nLMS Rn, (yy) 1 0 1 0 n (OH-FH)\n(3DH)\n(AnH)\nkk (OOH-FFH) (Address)\n[Short address method]\nMachine Cycles:\nNote:\nThis method is used by LMS, SMS, and other instructions to re\nduce the number of bytes in the instruction opcode. Only one\nbyte is used. The actual game pak RAM address is twice that of\nthe address code. The relationship between yy in the above syn\ntax and kk in the opcode is:\nyy = kk x 2\nROM execution time\nRAM execution time\nCache RAM execution time\n17 cycles\n17 cycles\n10 cycles\nThe GSU waits while data is loaded from game pak RAM. The\nexecution time required for this is included in the machine cycles\ngiven above.\n2-9-71", "SNES_DEV_book2.md" },
    HardwareQuirk{ "Note", "Example:\nDESCRIPTION OF INSTRUCTIONS\nROM execution time 10 or14 cycles\nRAM execution time 10 or14 cycles\nCache RAM execution time 5 or 9 cycles\nThe number of cycles varies depending upon the CFG R register\nsetting.\nUnder the following conditions,\nSreg: Rg, Dreg: Rs\nRg= B556H, R6= DAABH\nthe register Rs becomes OAE3H and R4 5C72H when\nLMULT\nis executed.\n2-9-74", "SNES_DEV_book2.md" },
    HardwareQuirk{ "Note", "When the value xx is even, the contents of (xx+ 1) are\nloaded to the high byte of Rn. When the value of xx is\nodd, the contents of (xx-1) are loaded to the high byte of\nRn\nIf (OOOOH~xx~01 FFH) and xx is even:\nthen, use an LMS instruction\nelse, use an LM instruction.\nThis instruction loads hexadecimal data contained in the game\npak RAM address specified in the second operand and stores\nthe data in register Rn, specified in the first operand .. The RAMB\ninstruction is used to specify the bank of the game pak RAM ad\ndress (refer to RAMB).\nThis is a macro instruction and is stored in memory as \"LM Rn,\n(xx)\" or \"LMS Rn, (yy).\" The assembler automatically recognizes\nwhether it should be replaced with an LM instruction or an LMS\ninstruction, depending upon the value of the game pak RAM ad\ndress specified.\nWhen the game pak RAM address is an even number of\n0-1 FFH, it is replaced with an LMS instruction. Otherwise, it is\nreplaced with an LM instruction. Refer to \"LM Rn, (xx)\" or \"LMS\nRn, (yy)\" for machine cycles, flags affected, and opcode.\nUnder the following conditions,\n(70:BACCH) = 28H, (70:BACDH) = 96H, RAMBR=70H\nthe register Rg becomes 9628H when the following program is\nexecuted:\nMOVE Rg, (OBACCH) ;(70:BACCH)~Rg(Low Byte) (LM Rg, (OBACCH))\n;(70:BACDH)~Rg(High Byte)\n2-9-83", "SNES_DEV_book2.md" },
    HardwareQuirk{ "Note", "If the value of xx is even, store the high byte of Rn at\n(xx+ 1). If the value of xx is odd, store the high byte of Rn\nat (xx-1).\nIf (0000H:s;xx:S;01 FFH) and xx is even:\nthen, use an SMS instruction,\nelse, use an SM instruction.\nThis instruction stores the contents (hexadecimal data) of regis\nter Rn specified in the second operand in the game pak RAM ad\ndress specified in the first operand. The RAMB instruction is\nused to specify the bank of the game pak RAM address (refer to\n\"RAMB\").\nThis macro instruction is stored in memory as \"SM (xx), Rn\" or\n\"SMS (yy) , Rn.\" The assembler automatically recognizes wheth\ner it should be replaced with an SM instruction or an SMS in\nstruction, depending upon the value of the game pak RAM\naddress specified.\nWhen the game pak RAM address is an even number of\n0-1 FFH, it is replaced with an SMS instruction. Otherwise, it is\nreplaced with an SM instruction. Refer to \"SM (xx), Rn\" and\n\"SMS (yy), Rn\" for machine cycles, flags affected, and opcode.\nUnder the following conditions,\nRg: BACDH, and RAMBR=71 H\nwhen the following program is executed,\nMOVE (9CDEH), Rg ;Rg (Low Byte)~(71 :9CDEH) (SM (9CDEH), Rg)\n;Rg (High Byte)~(71 :9CDFH)\nthe result is (71 :9CDEH)=CDH, (71 :9CDFH)=BAH\n2-9-85", "SNES_DEV_book2.md" },
    HardwareQuirk{ "Note", "If the contents of Rn' are even, store the address equal\nto the contents of (Rn'+ 1) in the high byte of Rn' If the\ncontents of Rn' are odd, store the address equal to\n(Rn'-1) in the high byte of Rn.\nIf n=O:\nthen, use only LDW instruction,\nelse, use TO instruction and LDW instruction.\nThis instruction loads hexadecimal data from the game pak RAM\naddress equal to the contents of register Rn' specified in the sec\nond operand and stores it into register Rn specified by the first\noperand. The game pak RAM address bank is specified using\nthe RAMB instruction (refer to RAMB).\nThis macro instruction is stored in memory as \"LDW (Rm)\" or ''TO\nRn\" + \"LDW (Rm).\" The assembler automatically recognizes\nwhether or not the TO instruction is required. When n is not\nequal to 0, the TO instruction is added. Refer to \"LDW (Rm)\" and\n\"TO Rn\" for machine cycles, flags affected, and opcode.\nUnder the following conditions,\nR3=6480H, (71 :6480H)=2EH, (71 :6481 H)=COH,\nRAMBR=71H\nand when the following program is executed,\nMOVEW R5, (R3) ;(R3)~R5(Low Byte) (TO R5 + LDB (R3))\n;(R3+ 1 )~R5(High Byte)\nregister R5 becomes C02EH.\nAlso, under the following conditions,\nR6=0822H, (70:0822H)=43H, (70:0823H)=96H,\nRAMBR=70H\nand when the following program is executed,\nMOVEW Ro, (R6) ;(R6)~Ro(Low Byte) (LDB (R6))\n;(R6+ 1 )~Ro(High Byte)\nregister Ro becomes 9643H.\n2-9-90", "SNES_DEV_book2.md" },
    HardwareQuirk{ "Note", "If the contents of Rn' are even, store the high byte of Rn\ninto the address equal to the contents of (Rn' + 1). If the\ncontents of Rn' are odd, store the high byte of Rn into\nthe address equal to the contents of (Rn'-1).\nIf n=O:\nthen, use only STW instruction,\nelse, use FROM instruction and STW instruction.\nThis instruction stores the contents (hexadecimal data) of regis\nter Rn specified in the second operand into the game pak RAM\naddress which is equal to the value of register Rn' specified in\nthe first operand. The game pak RAM address bank is specified\nusing the RAMB instruction (refer to RAMB). The operand n' can\nbe a register from Ro-R11 .\nThis macro instruction is stored in memory as \"STW (Rm)\" or\n\"FROM Rn\" + \"STW (Rm}'\" The assembler automatically recog\nnizes whether or not the FROM instruction is required. When n is\nnot equal to 0, the FROM instruction is added. Refer to \"STW\n(Rm) and \"FROM Rn\" for machine cycles, flags affected, and op\ncode.\nUnder the following conditions,\nRg=BFA3H, R10=4444H, RAMBR=71 H\nand when the following program is executed,\nMOVEW (R10), Rg ;Rg(Low Byte)~(R10} (FROM Rg+STW (R10))\n;Rg(High Byte)~(R10+1}\nthe result is (71 :4444H}=A3H, (71 :4445H}=BFH.\n2-9-91", "SNES_DEV_book2.md" },
    HardwareQuirk{ "Note", "Example:\nSreg (low byte) * Rn (low byte) ~ Dreg (n=0 .... 15)\nThis instruction performs a x a-bit signed multiplication using the\nlow byte of the source register and the low byte of register Rn.\nThe result is stored in the destination register.\nThe source and destination registers are specified in advance\nusing a FROM, WITH, or TO instruction. When not specified, the\nsource and destination registers default to Ro.\nThe operand can be a register Ro .... R1S.\nCY z\n*\nB : Reset\nALT1 : Reset\nALT2 : Reset\nS : Set when the result is negative, else reset.\nZ : Set on zero result, else reset.\n(MSB)\nROM execution time\nRAM execution time\n(LSB)\nn (OH-FH) I (8nH)\n3 or 5 cycles\n3 or 5 cycles\nCache RAM execution time 1 or 2 cycles\nThe number of cycles depends upon the CFGR register.\nUnder the following conditions,\nSreg: Rs, Dreg: R2\nRs=52CFH,R 1=63CFH\nthe register R2 becomes 0961 H when\nMULT R1\nis executed.\n2-9-93", "SNES_DEV_book2.md" },
    HardwareQuirk{ "Note", "Example:\nROM execution time 6 or 8 cycles\nRAM execution time 6 or 8 cycles\nCache RAM execution time 2 or 3 cycles\nThe number of cycles depends upon the CFG R register.\nUnder the following conditions,\nSreg: R3, Dreg:R4' R3= 95C6H\nthe register R4 becomes FDF6H when\nMULT #9\nis executed.\n2-9-94", "SNES_DEV_book2.md" },
    HardwareQuirk{ "Note", "RAM execution time 3-51 cycles\nCache RAM execution time 1-48 cycles\nBecause this instruction uses the RAM buffer, the number of ma\nchine cycles varies depending upon the program.\n2-9-100", "SNES_DEV_book2.md" },
    HardwareQuirk{ "Note", "Example:\nx (OOH-FFH)\nx (OOH-FFH)\nROM execution time\nRAM execution time\n(ADR8 Lower Byte)\n(ADR8 Upper Byte)\n12-17 cycles\n16-20 cycles\nCache RAM execution time 4-9 cycles\nBecause this instruction uses the RAM buffer, the number of cy\ncles varies depending upon the program.\nUnder the following conditions,\nR4= 438CH and RAMBR=70H\nthe following program execution,\n8M (OB492H), R4\nwill result in (70:B492H) =8CH, (70:B493H) = 43H.\n2-9-112", "SNES_DEV_book2.md" },
    HardwareQuirk{ "Note", "Selectable RAM address (yy) must be an even number.\nSimilar to SM, this instruction loads word data from register Rn,\nspecified in the second operand, and stores it in the game pak\nRAM address equal to the value specified in the first operand,\nyy. The selectable address is an even number 0 .... 510. The bank\nis specified with the RAMB instruction. This instruction uses the\nshort address method to reduce the number of bytes in the in\nstruction code.\nB\nIA~T1IA~T21 o~ I\nS CY Z\n0 -\nB : Reset\nALT1 : Reset\nALT2 : Reset\n(MSB) (LSB)\n0 0 1 1 1 I 1 I 1 I 0\nSMS (yy) , Rn 1 1 1 1 n (OH .... FH)\n(3EH)\n(AnH)\nkk (OOH .... FFH) (Address)\n[Short address method]\nMachine Cycles:\nNote:\nThis method is used by LMS, SMS and other instructions to re\nduce the number of bytes in the instruction code. One byte is\nused for the address. The selectable address may be an even\nnumber 0 .... 510. The relationship between yy in the syntax and kk\nin the opcode is:\nyy = kk x 2\nROM execution time\nRAM execution time\nCache RAM execution time\n9 .... 14 cycles\n13 .... 17 cycles\n3 .... 8 cycles\nBecause this instruction uses the RAM buffer, the number of ma\nchine cycles varies depending upon the program.\n2-9-113", "SNES_DEV_book2.md" },
    HardwareQuirk{ "Note", "Example:\n(m=O-11 )\nThis instruction stores the low byte of the source register in the\ngame pak RAM address equal to the value in the register speci\nfied in the operand. The operand can be a register Ro-R 11 . The\ngame pak RAM bank must be specified with the RAMB instruc\ntion.\nThe source register is specified in advance using a WITH or\nFROM instruction. When not specified, the register defaults to\nRo\nCY z\nB : Reset\nALT1 : Reset\nALT2 :Res~\n(MSB) (LSB)\n0 0 1\n0 0 1\n1\n1\n1 I 1 I 0 I 1\nm (OH-BH)\n(3DH)\n(3mH)\nROM execution time 6-9 cycles\nRAM execution time 8-14 cycles\nCache RAM execution time 2-5 cycles\nBecause this instruction uses the RAM buffer, the number of ma\nchine cycles varies depending upon the program.\nUnder the following conditions,\nSreg:R5, R5=216CH, Rs=9A34H, RAMBR=70H\nand when the following program is executed,\nSTB (Rs)\nthe result is (70:9A34H)=6CH.\n2-9-115", "SNES_DEV_book2.md" },
    HardwareQuirk{ "Note", "Example:\nSreg (low byte) ~ (Rm)\nSreg (high byte) ~ (Rm + 1)\n(m=O .... 11)\nWhen the contents of Rm are\neven, the high byte is\nstored at address (Rm+ 1 );\nWhen the contents of Rm are\nodd, the high byte is\nstored at address (Rm-1).\nThis instruction stores the contents of the source register into the\ngame pak RAM address specified in the operand, Rm' The RAM\nbank must be specified with the RAMB instruction. The operand\ncan be a register from Ro .... Rn .\nThe source register is specified in advance using WITH or\nFROM. When not specified, the register defaults to Ro.\nCY z\nB : Reset\nALT1 : Reset\nALT2 :Res~\n(MSB) (LSB)\nI 0 I 0 1 111m (OH-BH) 1 (3mH)\nROM execution time 3 .... 8 cycles\nRAM execution time 7 .... 11 cycles\nCache RAM execution time 1 .... 6 cycles\nBecause this instruction uses the RAM buffer, the number of cy\ncles varies depending upon the program.\nUnder the following conditions,\nSreg: R1o, R10=9326H, R2:5872H, RAMBR=70H\nand when the following program is executed,\nSTW (R2)\nthe result is (70:5872H}=26H, (70:5873H}=93H.\n2-9-117", "SNES_DEV_book2.md" },
    HardwareQuirk{ "Note", "Example:\nROM execution time 6 or 8 cycles\nRAM execution time 6 or 8 cycles\nCache RAM execution time 2 or 3 cycles\nThe number of cycles depends on the CON FIG register setting.\nUnder the following conditions,\nSreg: R3, Dreg: Ro, R3= 364FH, Rs= B2CFH\nthe register Ro becomes 3FE1 H when\nUMULT Rs\nis executed.\n2-9-122", "SNES_DEV_book2.md" },
    HardwareQuirk{ "Note", "To be compatible with the projection and attitude\ncontrol commands, the X axis shall be east-west\n(east = +), the Y axis shall be north-south (north =\n+), and the Z axis shall be up and down (up = +).\nNumber of Process Cycles: Input 1. Command Input 6\n2. e input 13\n3. ~ input 3\n4.~input 2\n5. x input 2\n6. Y input 2\n7.zinput 107\nOutput 1. X output 6\n2. Youtput 2\n3. Z output 4\n*Notes: 1. Parameters are input/output via the DR registers.\n2. Parameters are input/output in the order shown above. The\nnumber of cycles is the period until the next parameter can\nbe selected or the results of the calculation can be read.\nExample: [Coordinate calculation for three-dimensional rotation of an\nobject]\nThis command calculates the coordinates of an object after\nthree-dimensional rotation. (Refer to the diagram on the fol\nlowing page.)\n3-5-10", "SNES_DEV_book2.md" },
    HardwareQuirk{ "Note", "The origin coordinates of the screen designate the\ncenter of the screen.\nOutput: X[I] X coordinate of selected point\n(global coordinates, east is posi\ntive).\nY[I] Y coordinate of selected point\n(global coordinates, south is\npositive).\nThis command calculates the coordinates of a selected\n\"ground\" point on the screen. The command calculates\nthe global coordinates (X, Y) (the Z coordinate is zero) of\nthe point projected on a point selected by a cursor or tar\nget mark based on the screen coordinates (H,V) of the\nselected point.\nViewpoint\nFigure 3-5-13 Calculation of Coordinates for the Indicated Point on the Screen\n3-5-20", "SNES_DEV_book2.md" },
    HardwareQuirk{ "Note", "As shown below, the first row of the attitude matrix\nrepresents global coordinates of a unity vector (1,0,0) in\nthe forward direction in the object coordinate system.\n[\nMfX Mfy MfZ]\nS = (X, V, Z) (1,0,0) Mix Mly Mlz = (MfxMfyMfz)\nMux Muy Muz\nM is equal to A, B, or C; depending upon selected code.\n3-5-29", "SNES_DEV_book2.md" },
    HardwareQuirk{ "Note", "F, L, U axes represent the X, V, Z axes when ro\ntated <I> j, <Pi, 9i only.\nThis command determines the attitude angles (90 , <I> 0'\n<Po) of the body coordinates after the body with the atti\ntude angle (9j, <I> j, <pj) with respect to the global coordi\nnates are rotated by the minor displacement (~, d<l>,\nd<p). The body axes are rotated about the XVZ axes by\n(9j, <I> j, <Pi) to obtain the FLU axes. The FLU axes are\nthen rotated by (~, d<l>, d<p). This command calculates\nthe angles of the new FLU axes with respect to the XVZ\naxes. The order of rotation is V axis, X axis, and Z axis\n(L, F, and U axis).\n9j + sec<l>j (d9cos<pj - d<l>sin<pj) = 90\n<l>j+ (d9sin<pj+d<l>cos<pj) = <1>0\n<pj-tan<l>j(d9cos<pj+d<l>sin<pj) +d<p = <Po\n3-5-31", "SNES_DEV_book2.md" },
    HardwareQuirk{ "Note", "In this section, the timing charts for each 4021 Px flag (trig\nger, cursor, single/multiple shot, etc.) are expressed in negative\nlogic (active low); however, these are positive logic (active high) in\nthe Super NES program.\n4-4-11", "SNES_DEV_book2.md" },
    HardwareQuirk{ "NOTE", "Nintendo's products and game programs, designed in accordance\nwith these specifications, are subject to claims of patent and patent pending\nowned and/or licensed by Nintendo exclusively for the benefit of Nintendo\nand its authorized licensees. Nintendo does not license such rights for any\nother use or purpose. Nintendo does not warrant or represent against\nclaims of patent infringement by third parties.\n4-5-1", "SNES_DEV_book2.md" },
    HardwareQuirk{ "Note", "OOB, 01 B, and 10B are the mouse_spO and mouse_sp1 D1 and\nDO bit data.\n4-7-6", "SNES_DEV_book2.md" },
    HardwareQuirk{ "Note", "The normal state outputs \"1\" to PP7. After reading Controller Data 4\nand 5, the state should be returned to \"1\".\n4-9-5", "SNES_DEV_book2.md" },
    HardwareQuirk{ "Note", "Super NES CPU registers <421 CH> - <421 FH> are provided for\nexpansion of controller data storage. However, no data is stored in\nthis area by MultiPlayer 5 and data held by these registers is ig\nnored.\nIn addition to reading controller and other external device data automatical\nly, the Super NES can read data serially using software. Data can also be\nread using a combination of the automatic read function (up to16 bits) and\nsoftware (from the 17th bit).\n4-9-11", "SNES_DEV_book2.md" },
};

} // namespace z3dk
